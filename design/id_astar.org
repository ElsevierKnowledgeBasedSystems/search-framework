This document is to design the changes needed to implement IDA*.

* Successor generation
- Note that StateNeighbor has the same basic structure that we need to store moves, only the names are different.
- So, make a Neighbor base class with neutral names and derive from it StateNeighbor and MoveNeighbor.
- State will declare MoveNeighbor, /moves()/, /applyMove()/, /undoMove()/.
- In domains that can be used for both /A*/ and /IDA*/, /successors()/ can be implemented in terms of /move()/ and /applyMove()/.
* Logging
- We will keep all the needed things (state, g etc.) in a node (one node will be used throughout the search) and update that node in place. We will pass a pointer to this node to /log()/.
* Domains the do not have a /undoMove()/ function
- We define a MoveLock class that:
  + Stores a /unique_ptr/ to State (pointer to avoid initialization in case /State::undoMove()/ is declared.
  + Has type traits to determine whether /State::undoMove()/ is declared.
  + The constructor calls /State::applyMove(Node *, Move *)/. If /State::undoMove()/ is not declared, a copy of the current state is saved (a moving copy can be performed here).
  + The destructor calls /State::undoMove()/ if declared. Otherwise, it restores the state from the stored copy. A moving copy can be performed here.
- Note how the /MoveLock/ class is useful even without the issue of undefined /State::undoMove()/: it implements a RAII mechanism, so we cannot forget to undo the move!

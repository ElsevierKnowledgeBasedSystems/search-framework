This document intends to design the work with instance sets and the output of stats after running an algorithm on an instance set.

* Instance
- An instance can be things other than a /from-to/ pair of states. We already work on multiple goals, but who knows what future holds.
- Generically speaking, an instance holds all the information needed to know how the algorithm begins and when the problem is solved. This can be organized as an interface, so that an algorithm should not need to know how many start (or goal) states there are. In fact, from the point of view of an algorithm, /StartHandler/ and /GoalHandler/ *is* the instance. We already have /GoalHandler/ and we need to add /StartHandler/ for consistency, even though we do not have need for different /StartHandler/-s for now.    
- The mentioned handlers maintain data that is useful during the running of the algorithm, but is not needed during loading the instances and post-processing (e.g. outputting statistics). An example of such data is the list of achieved goals. So, let us have /StartData/ and /GoalData/ classes, which the respective handlers will inherit.
- For loading instances, an /Instance/ needs to contain an instance of /StartData/, of /GoalData/ and of /Properties/ (whatever information is stored with the instance, e.g. cost or bucket). For the first version, we can do without properties.
- An instance needs to know to save itself as well. We need a function to generate a random instance.
- The mentioned handlers need to be made prior to invoking an algorithm.
* Statistics
- A statistic is a counter associated with an event. Calculating average or percentile is a standard operation that can be implemented generically for any statistic. 
- Counters are cheap. We do not need to save on simple increment operations.
- Algorithm can have a function that returns a vector of statistics. This function would call similar functions on the closed list etc. So, there is chain effect whereby the stats from all components are gathered and joined into a single vector.
- This way each component is free to collect any stats it wants.
- A statistic is a template, so it can be /int/ or /double/. It also contains a name.

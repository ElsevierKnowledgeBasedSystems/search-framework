The way I am doing static configuration results in the problem of complicated dependencies, which are sometimes circular. 

* Example of circular dependencies
- Algorithms accepts instances, so they use Instance<State>.
- The constructor of Instance is parametrized on InstanceMeasures, with the default defined by the configuration.
- The cost instance measure needs to run an algorithm.
* Another example
- Command-line with additions. The additions are defined in extensions.
- Putting the CommandLine class after extensions does not solve the problem, since the command line is read throughout.
* Classification of dependencies:
- Dependent implementation, i.e. implementation that uses a type that has not been introduced. The solution is simple: all dependent implementations can be moved to the end.
- Dependent template type, i.e. type whose default template argument may be a type that has not been introduced. The solution is again simple: default template arguments can be forward-declared and this does not result in incomplete type problems!

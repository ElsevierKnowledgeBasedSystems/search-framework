#ifndef TYPIST_H
#define TYPIST_H

/// \file
/// \brief The \ref LogWindow class.
/// \author Meir Goldenberg

#include "form.h"

/// Makes sure the terminal is not left in mess in the case of a crash.
void sigterm_handler(int) {
    endwin();
    throw std::runtime_error(
        "The framework crashed. SIGSEGV signal is caught.");
}

/// Textual window the provides functionality for analyzing the log generated by
/// the search algorithm.
/// \tparam Node The search node type.
template <class Node> struct LogWindow {
    /// The type of the log of visual events.
    using MyVisualLog = VisualLog<Node>;

    /// Initializes all constituent pads of the window.
    /// \param log The visual log.
    LogWindow(const MyVisualLog &log) : log_(log) {
        signal(SIGSEGV, sigterm_handler);
        initscr();
        start_color();
        use_default_colors();
        init_pair(1, -1, -1);
        init_pair(2, COLOR_CYAN, -1);
        noecho();
        keypad(stdscr, TRUE);
        nodelay(stdscr, TRUE);
        curs_set(0);                // hide the cursor
        titlePad_ = newpad(1, 400); // enough for sure

        eventsPad_ = newpad(80, 400); // enough for sure

        messagesPad_ = newpad(1000, 400); // enough for sure

        menuPad_ = newpad(nMenuRows_, 80);
        keypad(menuPad_, TRUE);

        wbkgd(titlePad_, COLOR_PAIR(1));
        wbkgd(eventsPad_, COLOR_PAIR(1));
        wbkgd(messagesPad_, COLOR_PAIR(1));
        wbkgd(menuPad_, COLOR_PAIR(1));
    }

    /// Destroys the pads and the window.
    ~LogWindow() {
        delwin(titlePad_);
        delwin(eventsPad_);
        delwin(messagesPad_);
        delwin(menuPad_);
        endwin();
    }

    /// Displays the event belonging to the given row in the list of displayed
    /// events.
    /// \param row The row number in the list of displayed events.
    /// \note The displayed events include the events that are scrolled outside
    /// of the currently visible area. Depending on the current settings, a
    /// filtered out event may be counted among the displayed events. In this
    /// case, filtered and not filtered events are displayed differently.
    void printEvent(int row) {
        int step = rowToStep(row);
        if (!log_.inFilter(step))
            wattron(eventsPad_, COLOR_PAIR(2));
        wprintw(eventsPad_, "%s\n", str(logTable_.row(row)).c_str());
        if (!log_.inFilter(step))
            wattroff(eventsPad_, COLOR_PAIR(2));
    }

    /// Displays the currently visible events in the events pad.
    void updateEventsPad() {
        wclear(eventsPad_);
        wrefresh(eventsPad_);
        int first = firstRow();
        for (int i = first;
             i <= std::min(first + prefix_ + suffix_, logTable_.size() - 1);
             i++)
            printEvent(i);
    }

    /// Fills the events pad from the log of visual events.
    void fillEventsPad() {
        logTable_.clear();

        EventBase<Node>::dumpTitle(logTable_);
        for (auto &e : log_.algorithmLog().events())
            if (!hideFiltered_ || log_.inFilter(e->step())) {
                e->dump(logTable_);
                logTable_ << std::endl;
            }

        wclear(titlePad_);
        wrefresh(titlePad_);
        wattron(titlePad_, A_BOLD);
        wprintw(titlePad_, str(logTable_.row(0)).c_str());
        wattroff(titlePad_, A_BOLD);
        logTable_.remove(0);

        updateEventsPad();
        activateRow(stepToVisible(step_));
    }

    /// Displays all the pads with their contents.
    void show() {
        getmaxyx(stdscr, maxRow_, maxColumn_);
        showLog();
        showMessages();
        showMenu();
        refresh();
    }

    /// Returns the menu pad.
    /// \return The window identifier of the menu pad.
    WINDOW *menuPad() { return menuPad_; }

    /// Sets the current visual event to the given time point.
    /// \param step The time point of the new current visual event.
    void setStep(int step) {
        deactivateRow(stepToVisible(step_));
        activateRow(stepToVisible(step));
        if (step != step_) {
            step_ = step;
            updateEventsPad();
        }
    }

    /// Displays the given message in the messages pad.
    /// Does not display the same message twice.
    /// \param message The message to be displayed.
    void message(std::string message) {
        static std::string last;
        if (message == last) return;
        last = message;
        wprintw(messagesPad_, "%s\n", message.c_str());
        nMessages_++;
    }

    /// Sets the current menu and the current form.
    /// \param menu The new current menu identifier.
    /// \param form The new current form identifier.
    void setMenu(MENU *menu, Form *form) {
        menu_ = menu;
        form_ = form;
    }

    /// Sets the mode for either hiding or showing filtered out events.
    /// \param flag If \c true, the filtered out events will be hidden. They
    /// will be displayed (differently than the non-filtered once) otherwise.
    void hideFiltered(bool flag) { hideFiltered_ = flag; }

    /// Increases the horizontal scroll of the events pad.
    void scrollRight() { horizontalScroll_++; }

    /// Decreases the horizontal scroll of the events pad.
    void scrollLeft() {
        if (horizontalScroll_ > 0) horizontalScroll_--;
    }

private:
    const MyVisualLog &log_; ///< The log of visual events.
    Table logTable_{2};      ///< The output stream for displaying
                             /// the events nicely in columns.
    WINDOW *titlePad_;  ///< The pad that displays the headings of the columns
                        ///for the events shown in the events pad.
    WINDOW *eventsPad_; ///< The pad that displays the events.
    int step_ = 0;      ///< The current time point in the log of visual events.
    int horizontalScroll_ = 0; ///< The current value of horizontal scroll.

    int prefix_ = 5; ///< Number of visible events before the current event.
    int suffix_ = 5; ///< Number of visible events after the current event.

    WINDOW *messagesPad_; ///< The pad for displaying messages.
    int nShownMessages_ = 5; ///< The number of visible messages.
    int messagesBegin_ = prefix_ + suffix_ + 3; ///< The row in the window where
                                                /// the messages pad begins.

    WINDOW *menuPad_; ///< The pad for displaying the menu.

    /// The row in the window where the menu pad begins.
    int menuBegin_ = messagesBegin_ + nShownMessages_ + 2;
    int nMenuRows_ = 10; ///< The number of rows for the menu.
    MENU *menu_ = nullptr; ///< The active menu identifier.
    Form *form_ = nullptr; ///< The active form identifier.

    /// The mode for either hiding (if \c true) or showing filtered out events.
    bool hideFiltered_ = true;

    int nMessages_ = 0; ///< Current total number of messages.
    mutable int maxRow_, ///< Max row number in the window.
        maxColumn_;      ///< Max column number in the window.

    /// Computes the row in the events pad based on the time point in the log of
    /// visual events.
    /// \note The events pad includes the events that are scrolled outside
    /// of the currently visible area. Depending on the current settings (see
    /// \ref hideFiltered_), a
    /// filtered out event may be counted among the displayed events. In this
    /// case, filtered and not filtered events are displayed differently.
    /// \return The row in the events pad corresponding to the time point \c
    /// step.
    int stepToTableRow(int step) const {
        if (!hideFiltered_) return step;
        if (step == 0) return 0;
        return log_.stepToFiltered(step - 1) + 1;
    }

    /// Computes the first currently visible row of the events pad.
    /// \return The first currently visible row of the events pad.
    int firstRow() const {
        int activeRow = stepToTableRow(step_);
        return std::max(0, activeRow - prefix_);
    }

    /// Converts the time point in the log of visual events to the row in the
    /// visible part of the events pad.
    /// \return The row in the visible part of the events pad corresponding to
    /// the time point \c step in the log of visual events.
    int stepToVisible(int step) const {
        return stepToTableRow(step) - firstRow();
    }

    /// Computes the row in the visible part of the events pad based on the row
    /// in the events pad.
    /// \return The row in the visible part of the events pad corresponding to
    /// the row \c row in the events pad.
    int padToVisible(int row) const {
        return row + firstRow();
    }

    /// Converts the given row in the events pad to time point in the log of
    /// visual events.
    /// \return The time point in the log of visual events corresponding to the
    /// row \c row in the events pad.
    int rowToStep(int row) const {
        return hideFiltered_ ? log_.filteredToStep(row) : row;
    }

    /// Sets the display style of the event in the given row in the events pad.
    /// \param row The row in the events pad.
    /// \param attr Display style attributes to be turned on or off.
    /// \param flag If \c true the attribute \c attr is set on. Otherwise, it's
    /// set off.
    void rowMode(int row, int attr, bool flag) {
        int tableRow = padToVisible(row);
        int rowLimit = hideFiltered_ ? log_.nFilteredEvents() : log_.nEvents();
        if (tableRow < 0 || tableRow >= rowLimit) return;
        wmove(eventsPad_, row, 0);
        flag ? wattron(eventsPad_, attr) : wattroff(eventsPad_, attr);
        printEvent(tableRow);
        if (flag) wattroff(eventsPad_, attr);
    }

    /// Displays the event in the given row of the events pad as active.
    /// \param row The row of the events pad where the active event is displayed.
    void activateRow(int row) {
        rowMode(row - 1, A_UNDERLINE, true);
        rowMode(row, A_BOLD, true);
    }

    /// Displays the event in the given row of the events pad as inactive.
    /// \param row The row of the events pad where the now inactive event is
    /// displayed.
    void deactivateRow(int row) {
        rowMode(row - 1, A_UNDERLINE, false);
        rowMode(row, A_BOLD, false);
    }

    /// Displays the title pad and the events pad with its contents according to
    /// the current time point in the log of visual events and scrolling value.
    void showLog() {
        // int prefresh(WINDOW * pad, int pminrow, int pmincol, int sminrow,
        //              int smincol, int smaxrow, int smaxcol);
        //    pminrow and pmincol -- scroll values
        //    sminrow,  smincol,  smaxrow, smaxcol -- non-hidden area
        prefresh(titlePad_, 0, horizontalScroll_, 0, 0, 1, maxColumn_ - 1);
        int vScroll = 0;//std::max(0, stepToRow(step_) - prefix_);
        prefresh(eventsPad_, vScroll, horizontalScroll_, 1, 0,
                 prefix_ + suffix_ + 1, maxColumn_ - 1);
    }

    /// Display a title line in the given row of the window.
    /// \param row The row of the window.
    /// \param title The title to be displayed.
    void makeTitle(int row, const std::string &title) const {
        int hlineLength = (maxColumn_ - 1 - title.size()) / 2;
        mvhline(row, 0, ACS_HLINE, hlineLength);
        mvprintw(row, hlineLength, title.c_str());
        mvhline(row, hlineLength + title.size(), ACS_HLINE, hlineLength);
    }

    /// Displays the message pad with the currently visible messages.
    void showMessages() const {
        makeTitle(messagesBegin_, " Messages ");
        prefresh(messagesPad_, nMessages_ - nShownMessages_, 0,
                 messagesBegin_ + 1, 0, messagesBegin_ + nShownMessages_,
                 maxColumn_ - 1);
    }

    /// Displays the currently visible menu and form.
    void showMenu() const {
        makeTitle(menuBegin_, " Commands ");
        if (menu_ && form_ && !form_->empty())
            form_->display();
        prefresh(menuPad_, 0, 0, menuBegin_ + 1, 0,
                 std::min(menuBegin_ + nMenuRows_, maxRow_ - 1),
                 maxColumn_ - 1);
    }
};

#endif

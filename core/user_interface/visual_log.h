#ifndef VISUAL_LOG_H
#define VISUAL_LOG_H

/// \file
/// \brief The \ref VisualLog class.
/// \author Meir Goldenberg

#include "graphics_object.h"
#include "visual_event.h"

/// The log of events suited for visualization purposes.
/// This log is based on the \ref AlgorithmLog
/// generated by the search algorithm.
/// \tparam Node The node type.
/// \note It is not sufficient to keep the state type, since we need to hold a
/// reference to the original \ref AlgorithmLog.
template <class Node = SLB_NODE>
struct VisualLog: CurrentStyles<typename Node::State> {
    /// See \ref Events::Base<Node>::Event
    using AlgorithmEvent = typename Events::Base<Node>::Event;

    /// The state type, represents the domain.
    using State = typename Node::State;

    /// See \ref VisualEvent<Node>
    using MyVisualEvent = VisualEvent<State>;

    /// \name Types related to the graph of the domain.
    /// \see \ref StateGraph.
    /// @{
    using Graph = StateGraph<State>;
    using VertexDescriptor = typename Graph::VertexDescriptor;
    using EdgeDescriptor = typename Graph::EdgeDescriptor;
    using VertexStyle = typename MyVisualEvent::VertexStyle;
    using EdgeStyle = typename MyVisualEvent::EdgeStyle;
    /// @}

    /// \name Types related to visual representation of vertices and edges. See
    /// \see CurrentStyles.
    /// @{
    using Base = CurrentStyles<typename Node::State>;
    using Base::g_;
    using Base::vertexStyles_;
    using Base::edgeStyles_;
    /// @}

    /// Constructs visual log out of the log generated by the search algorithm.
    /// \param log The log generated by the search algorithm.
    /// \param g The (partial) domain graph.
    VisualLog(const AlgorithmLog<Node> &log, const Graph &g)
        : Base(g), log_(log) {
        for (auto vd : g_.vertexRange())
            vertexStyles_[vd] = VertexStyle();
        for (auto ed : g_.edgeRange())
            edgeStyles_[ed] = EdgeStyle();

        step_ = 0;
        for (auto &e: log.events()) {
            filteredToStep_.push_back(step_);
            stepToFiltered_.push_back(step_);
            auto ve = MyVisualEvent(g_, e, (*this));
            this->log(ve);
        }
        // rewind to the beginning
        reset();
        //while (step_ > 0)
        //    prev(temp);
    }

    /// Returns the visual event at the given point in time.
    /// \param The point in time.
    /// \return The the visual event at time \c step.
    MyVisualEvent event(int step) const { return events_[step]; }

    /// Checks whether the visual event at the given point in time is not
    /// filtered out by the current filter settings.
    /// \param The point in time.
    /// \return \c true if the visual event at time \c step is not filtered out
    /// by the current filter settings.
    bool inFilter(int step) const {
        return stepToFiltered_[step] != -1;
    }

    /// Returns the number of visual events in the log.
    /// \return The number of visual events in the log.
    int nEvents() const { return events_.size(); }

    /// Returns the number of visual events in the log that are not filtered out
    /// by the current filter settings.
    /// \return The number of visual events in the log that are not filtered out
    /// by the current filter settings.
    int nFilteredEvents() const { return filteredToStep_.size(); }

    /// Computes the index into the vector of events not filtered out
    /// by the current filter settings based on the give time point.
    /// \param The point in time.
    /// \return The index in the vector of events not filtered out
    /// by the current filter settings that corresponds to \c step.
    int stepToFiltered(int step) const { return stepToFiltered_[step]; }

    /// Inverse of \ref stepToFiltered.
    /// \param index Index in the vector of events not filtered out by the
    /// current filter settings.
    /// \return The point in time corresponding to \c index.
    int filteredToStep(int index) const { return filteredToStep_[index]; }

    /// Moves forward in the log to the given time point and visualizes the
    /// change in the state of the algorithm.
    /// \tparam Drawer The drawer type.
    /// \param step The target time point.
    /// \param drawer The drawer.
    /// \param groupFlag If \c true, \ref GroupLock is grabbed. Grabbing \ref
    /// GroupLock is not always necessary (e.g. when the calling function
    /// grabbed its own lock).
    template <class Drawer>
    void move(int step, Drawer &drawer, bool groupFlag = false) {
        GroupLock lock{groupFlag, drawer.graphics()}; (void)lock;
        while (step_ != step) {
            step_ < step ? next(drawer, false) : prev(drawer, false);
        }
    }

    /// Moves in the log to the next visual event not filtered out by the
    /// current filter and visualizes the change in the state of the algorithm.
    /// \tparam Drawer The drawer type.
    /// \param drawer The drawer.
    /// \param groupFlag If \c true, \ref GroupLock is grabbed. Grabbing \ref
    /// GroupLock is not always necessary (e.g. when the calling function
    /// grabbed its own lock).
    /// \return \c true if the time point has been changed.
    template <class Drawer> bool next(Drawer &drawer, bool groupFlag = true) {
        //for (int i = 0; i < 2; i++) {
        GroupLock lock{groupFlag, drawer.graphics()}; (void)lock;
        if (step_ - 1 == filteredToStep_.back()) return false;
        do {
            if (!stepForward(drawer)) return false;
        } while (!inFilter(step_ - 1));
        //}
        return true;
    }

    /// Moves in the log to the last visual event not filtered out by the
    /// current filter and visualizes the change in the state of the algorithm.
    /// \tparam Drawer The drawer type.
    /// \param drawer The drawer.
    /// \param groupFlag If \c true, \ref GroupLock is grabbed. Grabbing \ref
    /// GroupLock is not always necessary (e.g. when the calling function
    /// grabbed its own lock).
    /// \return \c true if the time point has been changed.
    template <class Drawer> bool prev(Drawer &drawer, bool groupFlag = true) {
        GroupLock lock{groupFlag, drawer.graphics()}; (void)lock;
        do {
            if (!stepBackward(drawer)) return false;
        } while (!inFilter(step_ - 1));
        return true;
    }

    /// Moves forward in the log to the next visual event filtered out by
    /// neither the current filter nor the given search filter.
    /// Visualizes the change in the state of the algorithm.
    /// \tparam Filter The type of the search filter.
    /// \tparam Drawer The drawer type.
    /// \param filter The search filter.
    /// \param drawer The drawer.
    /// \return \c true if the time point has been changed.
    template <class Filter, class Drawer>
    bool next(const Filter &searchFilter, Drawer &drawer) {
        GroupLock lock{true, drawer.graphics()}; (void)lock;
        int origStep = step_;
        do {
            if (!next(drawer, false)) {
                move(origStep, drawer);
                return false;
            }
        } while (!searchFilter.in(algorithmEvent(step_ - 1)));
        return true;
    }

    /// Moves backward in the log to the last visual event filtered out by
    /// neither the current filter nor the given search filter.
    /// Visualizes the change in the state of the algorithm.
    /// \tparam Filter The type of the search filter.
    /// \tparam Drawer The drawer type.
    /// \param filter The search filter.
    /// \param drawer The drawer.
    /// \return \c true if the time point has been changed.
    template <class Filter, class Drawer>
    bool prev(const Filter &searchFilter, Drawer &drawer) {
        GroupLock lock{true, drawer.graphics()}; (void)lock;
        int origStep = step_;
        do {
            if (!prev(drawer, false)) {
                move(origStep, drawer);
                return false;
            }
        } while (!searchFilter.in(algorithmEvent(step_ - 1)));
        return true;
    }

    /// Resets the current time point to the beginning of the visual log.
    void reset() {
        while (step_ > 0) {
            auto e = events_[--step_];
            unApplyEvent(e);
        }
    }

    /// Returns the current time point.
    /// \return The current time point.
    int step() const { return step_; }

    /// Returns the \ref AlgorithmLog on which this visual log is based.
    /// \return The \ref AlgorithmLog on which this visual log is based.
    const AlgorithmLog<Node> &algorithmLog() const { return log_; }

    /// Returns the current styles of visual vertex and edge representations.
    /// \return The current styles of visual vertex and edge representations.
    Base &currentStyles() { return *this; }

    /// Returns the event generated by the search algorithm that corresponds to
    /// the visual event at the given time point.
    /// \param step The time point.
    /// \return The generated by the search algorithm at time point \c step.
    const AlgorithmEvent &algorithmEvent(int step) const {
        return log_.events()[step];
    }

    /// Sets the current filter. The filter will affect all consequent calls to
    /// \ref VisualLog::inFilter, \ref VisualLog::nFilteredEvents, \ref
    /// VisualLog::stepToFiltered, \ref VisualLog::filteredToStep, \ref
    /// VisualLog::next, \ref VisualLog::prev.
    /// \tparam Filter The filter type.
    /// \tparam Drawer The drawer type.
    /// \param filter The new filter.
    /// \param drawer The drawer.
    template <class Filter, class Drawer>
    void setFilter(const Filter &filter, Drawer &drawer) {
        filteredToStep_.clear();
        for (auto &e : log_.events())
            if (filter.in(e)) filteredToStep_.push_back(e->step());

        stepToFiltered_.resize(events_.size());
        std::fill(stepToFiltered_.begin(), stepToFiltered_.end(), -1);
        int filteredStep = 0;
        for (auto step : filteredToStep_)
            stepToFiltered_[step] = filteredStep++;
        if (!inFilter(step_)) prev(drawer);
    }

    /// Moves one time point forward in the log.
    /// \return \c true if the time point has been changed.
    bool stepForward() {
        if (step_ >= events_.size()) return false;
        auto e = events_[step_];
        applyEvent(e);
        step_++;
        return true;
    }

    /// Moves one time point backward in the log.
    /// \return \c true if the time point has been changed.
    bool stepBackward() {
        if (step_ <= 0) return false;
        auto e = events_[step_ - 1];
        unApplyEvent(e);
        step_--;
        return true;
    }

private:
    /// The log of events generated by the search algorithm.
    const AlgorithmLog<Node> &log_;

    /// All the visual events in the visual log.
    std::vector<MyVisualEvent> events_;

    /// The current time point. events_[step_] is the event about to happen.
    int step_;

    /// \name Encoding of the current filter.
    /// @{
    /// For each time point, this vector stores the corresponding index of event
    /// not filtered out by the current filter.
    std::vector<int> filteredToStep_;

    /// For each event not filtered out by the current filter, this vector
    /// stores the time point of that event.
    std::vector<int> stepToFiltered_; // -1 if not in filtered
    /// @}

    /// Moves one time point forward in the log and visualizes the
    /// change in the state of the algorithm.
    /// \tparam Drawer The drawer type.
    /// \param drawer The drawer.
    /// \return \c true if the time point has been changed.
    template <class Drawer> bool stepForward(Drawer &drawer) {
        if (!stepForward()) return false;
        auto e = events_[step_ - 1];
        e.draw(drawer);
        return true;
    }

    /// Moves one time point backward in the log and visualizes the
    /// change in the state of the algorithm.
    /// \tparam Drawer The drawer type.
    /// \param drawer The drawer.
    /// \return \c true if the time point has been changed.
    template <class Drawer> bool stepBackward(Drawer &drawer) {
        if (!stepBackward()) return false;
        auto e = events_[step_];
        e.draw(drawer, true);
        return true;
    }

    /// Changes the current visual presentation styles of vertices and edges by
    /// applying the given visual event.
    /// \param e The visual event to be applied.
    void applyEvent(const MyVisualEvent &e) {
        for (auto &vertexChange: e.vertexChanges())
            vertexStyles_[vertexChange.vd] = vertexChange.now;

        for (auto &edgeChange : e.edgeChanges())
            edgeStyles_[edgeChange.ed] = edgeChange.now;
    }

    /// Changes the current visual presentation styles of vertices and edges by
    /// applying the inverse of the given visual event.
    /// \param e The visual event to be reversed.
    void unApplyEvent(const MyVisualEvent &e) {
        for (auto &vertexChange: e.vertexChanges())
            vertexStyles_[vertexChange.vd] = vertexChange.before;

        for (auto &edgeChange : e.edgeChanges())
            edgeStyles_[edgeChange.ed] = edgeChange.before;
    }

    /// Adds a given visual event to the visual log.
    /// \param e The visual event to be added.
    void log(const MyVisualEvent &e) {
        applyEvent(e);
        events_.push_back(e);
        step_++;
    }
};

#endif

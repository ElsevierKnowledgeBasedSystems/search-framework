#ifndef SLB_CORE_USER_INTERFACE_EVENT_BASE_H
#define SLB_CORE_USER_INTERFACE_EVENT_BASE_H

/// \file
/// \brief The base class for the events generated by the search algorithm.
/// \author Meir Goldenberg

#include "algorithm_log.h"
#include "current_styles.h"

namespace slb {
namespace core {
namespace ui {

/// Type of event.
enum class EventType {
    NORMAL,         /// As it sounds. Most events are normal.
    HIDE_LAST_EVENT /// A special event that reverses the visual changes of the
                    /// event before it.
};

/// The base class for the events generated by the search algorithm.
/// Note that an event carries with it the information about its visualization
/// as well. This information is the basis for building a visual event
/// (\ref VisualEvent) out of it.
/// \tparam Node The node type. An event usually carries data from a search
/// node. This data is used to display the event in the log window.
template <class Node = SLB_NODE> struct EventBase {
    /// The state type, represents the domain.
    using State = typename Node::State;

    /// Smart pointer to state.
    using StateSharedPtr = deref_shared_ptr<const State>;

    /// Type for data carried with a node.
    using NodeData = typename Node::NodeData;

    /// Smart pointer to an event generated by the search algorithm.
    using Event = std::shared_ptr<EventBase<Node>>;

    /// Description of change of visual representation a state.
    /// Note that this is different from a visual event
    /// (see \ref VisualEvent::VertexChange), which associates changes
    /// with vertices of the domain graph.
    struct VertexChange {
        StateSharedPtr s;   ///< The state.
        VertexStyle now;    ///< The new representation.
        VertexStyle before; ///< The previous representation.
    };

    /// Description of change of visual representation of an edge.
    /// An edge is represented here by a pair of smart pointers to states.
    /// Note that this is different from a visual event
    /// (see \ref VisualEvent::EdgeChange), in which an edge is represented here
    /// by a pair of vertices of the domain graph.
    struct EdgeChange {
        StateSharedPtr from;     ///< The source state of the edge.
        StateSharedPtr to;       ///< The target state of the edge.
        EdgeStyle now;           ///< The new representation.
        EdgeStyle before;        ///< The previous representation.
    };

    /// Changes of visual representations associated with states and edges.
    struct VisualChanges {
        /// Changes of visual representations associated with states.
        std::vector<VertexChange> vChanges;
        /// Changes of visual representations associated with edges.
        std::vector<EdgeChange> eChanges;
    };

    /// Initializes the event based on the given search node.
    /// \param log The log that contains the event. This means that the log
    /// is an intrusive container. See \ref AlgorithmLog.
    /// \param n The node.
    /// \param parentSubstitution The node whose state should be used as a
    /// parent state instead of the parent stored in \n. See How the \ref
    /// ext::event::NothingToDo event is generated in \ref ext::algorithm::Astar
    /// for an example of when this is useful.
    EventBase(const AlgorithmLog<Node> &log, const Node *n,
              const Node *parentSubstitution = nullptr)
        : log_(log), state_(stateFromNode(n)),
          parent_(n->parent() ? stateFromNode(n->parent()) : nullptr),
          parentSubstitution_(
              parentSubstitution ? stateFromNode(parentSubstitution) : nullptr),
          nodeData_(*n), step_(log.size()),
          lastStateEvent_(log.getLastEvent(state_, false)),
          lastParentEvent_(parent_ ? log.getLastEvent(parent_) : nullptr) {}

    virtual ~EventBase() {}

    /// Returns the time point when the event happened.
    /// \return The time point when the event happened.
    int step() const { return step_; }

    /// Returns the log containing the event.
    /// \return Const reference to the log containing the event.
    const AlgorithmLog<Node> &log() const { return log_; }

    /// Returns the state with which the event is associated.
    /// \return Const reference to the state with which the event is associated.
    const StateSharedPtr &state() const { return state_; }

    /// Returns the state from which the search algorithm arrived to the state
    /// with which the event is associated.
    /// \return Const reference to the parent state.
    const StateSharedPtr &parent() const { return parent_; }

    /// Returns the information kept with the search node from which the event
    /// was constructed.
    /// \return Const reference to the structure with the information kept
    /// with the search node, from which the event was constructed..
    const NodeData &nodeData() const { return nodeData_; }

    /// Returns latest among the past events for the state.
    /// \return Smart pointer to the latest among the past events for the state.
    Event lastStateEvent() const { return lastStateEvent_; }

    /// Returns latest among the past events for the parent state.
    /// \return Smart pointer to the latest among the past events for the parent
    /// state.
    Event lastParentEvent() const { return lastParentEvent_; }

    /// Returns the string describing the event. This string is displayed in the
    /// log window.
    /// \return The string describing the event.
    virtual std::string eventStr() const = 0;

    /// Returns the event type (see \ref EventType).
    /// \return The event type.
    virtual EventType eventType() const { return EventType::NORMAL; }

    /// Uses the log to compute the path which the search algorithm found to
    /// arrive to the given state.
    /// \param state The state to which the path is sought.
    /// \return A vector of states representing the path found by the search
    /// algorithm found to arrive to \c state.
    std::vector<StateSharedPtr> path(const StateSharedPtr &state) const {
        std::vector<StateSharedPtr> res;
        Event e = log_.getLastEvent(state);
        while (e) {
            res.push_back(e->state());
            e = e->lastParentEvent();
        }
        std::reverse(res.begin(), res.end());
        return res;
    }

    /// Computes changes of visual representations associated with states and
    /// edges defined by the event.
    /// \param styles The current visual representations of states and edges.
    /// This can
    /// be used for the computation in the derived classes.
    virtual VisualChanges
    visualChanges(const CurrentStyles<State> &styles) const {
        (void)styles; // so `styles` can be documented
        return VisualChanges();
    }

    /// Dumps the event into a given output stream in column format. The stream
    /// will usually be a \ref util::Table, which handles the column width
    /// automatically.
    /// \tparam Stream The output stream type.
    /// \param o The output stream.
    template <class Stream>
    Stream &dump(Stream &o) const {
        o << std::setw(6) << step_;
        o << std::setw(18) << str(*state_) << std::setw(32) << eventStr();

        if (parent_)
            o << std::setw(18) << str(*parent_);
        else
            o << std::setw(18) << "n/a";
        o << std::setw(12) << nodeData_;
        return o;
    }

    // // For debugging only
    // void dump() const {
    //     std::cerr << step_ << " " << eventStr() << "    State: " << str(*state_)
    //               << "   Parent: " << (parent_ ? str(*parent_) : "none")
    //               << "   Subst.: "
    //               << (parentSubstitution_ ? str(*parentSubstitution_) : "none")
    //               << std::endl;
    // }

    /// To be used in conjunction with \ref dump. Dumps the titles of
    /// the columns.
    /// \tparam Stream The output stream type.
    /// \param o The output stream.
    template <class Stream> // can be Table
    static Stream &dumpTitle(Stream &o) {
        o << std::setw(6) << "Step" << std::setw(18) << "State" << std::setw(32)
          << "EventStr" << std::setw(18) << "Parent" << std::setw(12) << "Note"
          << std::endl;
        return o;
    }
protected:
    /// The log containing the event.
    const AlgorithmLog<Node> &log_;

    /// The state with which the event is associated.
    StateSharedPtr state_;

    /// the state from which the search algorithm arrived to \ref state_.
    StateSharedPtr parent_;
    /// The node whose state should be used as a
    /// parent state instead of the parent stored in \n. See how the \ref
    /// ext::event::NothingToDo event is generated in \ref ext::algorithm::Astar
    /// for an example of when this is useful.
    StateSharedPtr parentSubstitution_;

    /// The information that was kept with the search node from which the event
    /// was constructed at the moment of construction.
    NodeData nodeData_;

    /// The time point when the event happened.
    int step_;

    /// The latest among the past events for the state.
    Event lastStateEvent_;

    /// The latest among the past events for the parent state.
    Event lastParentEvent_;

private:
    /// Get a smart pointer to the state stored with the given search node.
    /// n The search node.
    /// \return Smart pointer to the state stored with \c n.
    StateSharedPtr stateFromNode(const Node *n) {
        return make_deref_shared<const State>(n->state());
    }
};

} // namespace
} // namespace
} // namespace

#endif

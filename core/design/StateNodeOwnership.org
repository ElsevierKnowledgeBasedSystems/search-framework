
* This document is my thought process on the topic:
Who owns the states and the nodes?

* To answer this question, we need to follow the life cycle of a state and of a node and see how the ownership is transferred/shared.

* The result of this process should be:
Clarity when to use regular pointers/references or smart pointers.

* State:
- Born in the domain’s (i.e. State class’s) /neighbors()/ function. The state is immediately wrapped in /unique pointer/ and is returned to the caller as a vector of states or state-cost pairs.
- For each state in the aforementioned vector, the caller of /neighbors()/  forms a node (wrapping it immediately in /unique pointer/) and transfers the ownership of the state to that node.
- The node and the state remain married until the node is automatically destroyed and the state is destroyed with it.
- This means that no other entity takes ownership of the state and so the state can always be passed /by reference/.
- Also, the node’s /state()/ member function should return a /reference/. 

* Node:
- Born as described above in the caller of the domain’s (i.e. State class’s) /neighbors()/ function immediately after that call.
- If the node needs to be added to /OC/, the latter assumes ownership of the node. The A* code continues to use the pointer without owning the node.
- Since /OC/ gets ownership, it’s /add()/ member function should take /unique pointer/ argument.  
- If the node needs to be updated in /OC/, the node is already owned by /OC/ and A* only gets to see the /reference/.

** Ownership of the node within OC: 
- The hash (the value part) assumes ownership of the node. Hence, the key part is regular State pointer and the heap stores regular Node pointers.

* Lastly, there is no need for the flexibility allowed by NodeP template parameter.  
This flexibility was important in the generic libraries of Stepanov. BTW, there the only requirement was that the pointer supports -> and *. Here, since /unique pointer/ features performance comparable to regular pointer, there is not really a need to give the user the ability to not use smart pointers. So, we should go for the simplest code possible.

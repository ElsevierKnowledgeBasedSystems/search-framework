#ifndef GOAL_HANDLER_H
#define GOAL_HANDLER_H

/// \file
/// \brief Policies for handling conditions related to goal states.
/// \author Meir Goldenberg

/// Handling conditions related to goal states for the case when the set of the
/// goal states is empty.
template <class State, class Log> // for uniformity
struct NoGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    NoGoalHandler(MyInstance &, Log &) {}

    /// Handles selection of a node by the search algorithm.
    /// \tparam Node The search node type.
    template <class Node> void onSelect(const Node *, CostType &) {}

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return false;}

    /// Passes the goals to the log of the search algorithm. In this particular
    /// case, there are no goals to pass.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {}
};

/// Handling conditions related to goal states for the case when there is a
/// single goal state.
template <class State, class Log>
struct SingleGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param instance The problem instance.
    /// \param log The log of events generated by the search algorithm.
    SingleGoalHandler(MyInstance &instance, Log &log)
        : goal_(instance.goal()), log_(log) {}

    /// Handles selection of a node by the search algorithm.
    /// \tparam Node The search node type.
    /// \param n Pointer to the node that was selected by the search algorithm.
    /// \param res The cost that will be returned by the search algorithm to be
    /// filled out. In this case, it's trivially \c n->f when \c n is
    /// corresponds to the goal.
    template <class Node> void onSelect(const Node *n, CostType &res) {
        if (n->state() == goal_) {
            // std::cerr << "DONE_GOAL " << n->state() << " " << n->f
            //           << std::endl;
            res = n->f;
            done_ = true;
            log<Events::SolvedGoal>(log_, n);
            log<Events::HideLast>(log_, n);
        }
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm. In this particular
    /// case, there is only a single goal to pass.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        log<Events::MarkedGoal>(log_, std::make_shared<Node>(goal_).get());
    }
private:
    State goal_; ///< The goal state.
    Log &log_; ///< The log of events generated by the search algorithm.
    bool done_ = false; ///< Flag showing whether the search algorithm has
                        ///accomplished its mission and should terminate.
};

/// Handling conditions related to goal states for the case when there are
/// multiple goal states.
template <class State, class Log>
struct MultipleGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param instance The problem instance.
    /// \param log The log of events generated by the search algorithm.
    MultipleGoalHandler(MyInstance &instance, Log &log)
        : goals_(instance.goals()), log_(log) {}

    /// Handles selection of a node by the search algorithm.
    /// \tparam Node The search node type.
    /// \param n Pointer to the node that was selected by the search algorithm.
    /// \param res The cost that will be returned by the search algorithm to be
    /// filled out. In this case, we accumulate the average cost for reaching
    /// the goals.
    template <class Node> void onSelect(const Node *n, CostType &res) {
        { // Check current goals
            auto it = std::find(goals_.begin(), goals_.end(), n->state());
            if (it != goals_.end()) {
                // std::cerr << "DONE_GOAL " << n->state() << " " << n->f
                //           << std::endl;
                res =
                    (res * doneGoals_.size() + n->f) / (doneGoals_.size() + 1);
                goals_.erase(it);
                doneGoals_.push_back(n->state());
                if (goals_.empty()) done_ = true;
                log<Events::SolvedGoal>(log_, n);
                log<Events::HideLast>(log_, n);
            }
        }
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        for (auto &g: goals_)
            log<Events::MarkedGoal>(log_, std::make_shared<Node>(g).get());
    }
private:
    /// The goal states.
    /// \note Changes to goals_ will also be seen by the heuristic.
    std::vector<State> &goals_;

    /// The goals that have already been found.
    std::vector<State> doneGoals_;

    /// The log of events generated by the search algorithm.
    Log &log_;

    /// Flag showing whether the search algorithm has accomplished its mission
    /// and should terminate.
    bool done_ = false;
};

/// Handling conditions related to goal states for the case when there are
/// multiple goal states and a heuristic that stores the goal state responsible
/// for the heuristic value is used.
template <class State, class Log>
struct MinHeuristicGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param instance The problem instance.
    /// \param log The log of events generated by the search algorithm.
    MinHeuristicGoalHandler(MyInstance &instance, Log &log)
        : goals_(instance.goals()), log_(log) {}

    /// Handles selection of a node by the search algorithm. If the goal
    /// responsible for the heuristic value of the node had been found with the
    /// required quality, then \c false is returned indicating the suspension of
    /// expansion of this node.
    /// \tparam Node The search node type.
    /// \param n Pointer to the node that was selected by the search algorithm.
    /// \param res The cost that will be returned by the search algorithm to be
    /// filled out. In this case, we accumulate the average cost for reaching
    /// the goals.
    /// \return \c false if the goal responsible for the heuristic value of \c n
    /// had been found with the required quality and \c true otherwise.
    template <class Node> bool onSelect(const Node *n, CostType &res) {
        { // Check identity of goal resposible for heuristic
            auto it = std::find(doneGoals_.begin(), doneGoals_.end(),
                                n->responsibleGoal);
            if (it != doneGoals_.end()) {
                log<Events::SuspendedExpansion>(log_, n);
                return false;
            }
        }
        { // Check current goals
            auto it = std::find(goals_.begin(), goals_.end(), n->state());
            if (it != goals_.end()) {
                // std::cerr << "DONE_GOAL " << n->state() << " " << n->f
                //           << std::endl;
                res =
                    (res * doneGoals_.size() + n->f) / (doneGoals_.size() + 1);
                goals_.erase(it);
                doneGoals_.push_back(n->state());
                if (goals_.empty()) done_ = true;
                log<Events::SolvedGoal>(log_, n);
                log<Events::HideLast>(log_, n);
            }
        }
        return true;
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        for (auto &g : goals_)
            log<Events::MarkedGoal>(log_, std::make_shared<Node>(g).get());
    }
private:
    /// The goal states.
    /// \note Changes to goals_ will also be seen by the heuristic.
    std::vector<State> &goals_;

    /// The goals that have already been found.
    std::vector<State> doneGoals_;

    /// The log of events generated by the search algorithm.
    Log &log_;

    /// Flag showing whether the search algorithm has accomplished its mission
    /// and should terminate.
    bool done_ = false;
};

#endif

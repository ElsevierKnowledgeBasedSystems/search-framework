#ifndef GOAL_HANDLER_H
#define GOAL_HANDLER_H

/// \file
/// \brief Policies for handling conditions related to goal states.
/// \author Meir Goldenberg

/// Handling conditions related to goal states for the case when the set of the
/// goal states is empty.
/// \tparam Algorithm The search algorithm.
template <class MyAlgorithm> // for uniformity
struct NoGoalHandler {
    POLICY_TYPES

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    NoGoalHandler(MyAlgorithm &) {}

    /// Handles selection of a node by the search algorithm.
    void onSelect() {}

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return false;}

    /// Passes the goals to the log of the search algorithm. In this particular
    /// case, there are no goals to pass.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {}
};

/// Handling conditions related to goal states for the case when there is a
/// single goal state.
template <class State, class Log>
struct SingleGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param instance The problem instance.
    /// \param log The log of events generated by the search algorithm.
    SingleGoalHandler(MyInstance &instance, Log &log)
        : goal_(instance.goal()), log_(log) {}

    /// Handles selection of a node by the search algorithm.
    /// \tparam Node The search node type.
    /// \param n Pointer to the node that was selected by the search algorithm.
    /// \param res The cost that will be returned by the search algorithm to be
    /// filled out. In this case, it's trivially \c n->f when \c n is
    /// corresponds to the goal.
    template <class Node> void onSelect(const Node *n, CostType &res) {
        if (n->state() == goal_) {
            // std::cerr << "DONE_GOAL " << n->state() << " " << n->f
            //           << std::endl;
            res = n->f;
            done_ = true;
            log<Events::SolvedGoal>(log_, n);
            log<Events::HideLast>(log_, n);
        }
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm. In this particular
    /// case, there is only a single goal to pass.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        log<Events::MarkedGoal>(log_, std::make_shared<Node>(goal_).get());
    }
private:
    State goal_; ///< The goal state.
    Log &log_; ///< The log of events generated by the search algorithm.
    bool done_ = false; ///< Flag showing whether the search algorithm has
                        ///accomplished its mission and should terminate.
};

/// Handling conditions related to goal states for the case when there are
/// multiple goal states.
template <class State, class Log>
struct MultipleGoalHandler {
    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// Type for action cost in the search domain.
    using CostType = typename State::CostType;

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param instance The problem instance.
    /// \param log The log of events generated by the search algorithm.
    MultipleGoalHandler(MyInstance &instance, Log &log)
        : goals_(instance.goals()), log_(log) {}

    /// Handles selection of a node by the search algorithm.
    /// \tparam Node The search node type.
    /// \param n Pointer to the node that was selected by the search algorithm.
    /// \param res The cost that will be returned by the search algorithm to be
    /// filled out. In this case, we accumulate the average cost for reaching
    /// the goals.
    template <class Node> void onSelect(const Node *n, CostType &res) {
        { // Check current goals
            auto it = std::find(goals_.begin(), goals_.end(), n->state());
            if (it != goals_.end()) {
                // std::cerr << "DONE_GOAL " << n->state() << " " << n->f
                //           << std::endl;
                res =
                    (res * doneGoals_.size() + n->f) / (doneGoals_.size() + 1);
                goals_.erase(it);
                doneGoals_.push_back(n->state());
                if (goals_.empty()) done_ = true;
                log<Events::SolvedGoal>(log_, n);
                log<Events::HideLast>(log_, n);
            }
        }
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        for (auto &g: goals_)
            log<Events::MarkedGoal>(log_, std::make_shared<Node>(g).get());
    }
private:
    /// The goal states.
    /// \note Changes to goals_ will also be seen by the heuristic.
    std::vector<State> &goals_;

    /// The goals that have already been found.
    std::vector<State> doneGoals_;

    /// The log of events generated by the search algorithm.
    Log &log_;

    /// Flag showing whether the search algorithm has accomplished its mission
    /// and should terminate.
    bool done_ = false;
};

/// Handling conditions related to goal states for the case when there are
/// multiple goal states and a heuristic that stores the goal state responsible
/// for the heuristic value is used.
/// \tparam Algorithm The search algorithm.
template <class MyAlgorithm>
struct MinHeuristicGoalHandler {
    POLICY_TYPES

    /// Initializes the policy based on a problem instance and a log of events
    /// generated by the search algorithm.
    /// \param alg Reference to the search algorithm.
    MinHeuristicGoalHandler(MyAlgorithm &alg)
        : alg_(alg), goals_(alg.instance().goals()), log_(alg.log()) {}

    /// Handles selection of a node by the search algorithm. If the goal
    /// responsible for the heuristic value of the node had been found with the
    /// required quality, the heuristic is re-computed based on the remaining
    /// goals. If the node's cost grows based on that check, then \c false is
    /// returned indicating the denial of expansion of this node.
    /// \return \c true if the currently selected node should be expanded and \c
    /// false otherwise.
    bool onSelect() {
        Node *n = alg_.cur();
        // Check identity of goal resposible for heuristic
        if (in(doneGoals_, n->responsibleGoal)) {
            log<Events::SuspendedExpansion>(log_, n);
            return !isDenied(n);
        }

        if (inErase(goals_, n->state())) doneGoal(n);

        return true;
    }

    /// Returns \c true if all the goals were found with the required quality
    /// and the search algorithm should terminate. Returns \c false otherwise.
    /// \return \c true if all the goals were found with the required quality
    /// and \c false otherwise.
    bool done() const {return done_;}

    /// Passes the goals to the log of the search algorithm.
    /// \tparam Node The search node type.
    template <class Node> void logInit() {
        for (auto &g : goals_)
            log<Events::MarkedGoal>(log_, std::make_shared<Node>(g).get());
    }
private:
    /// Reference to the search algorithm.
    MyAlgorithm &alg_;

    /// The goal states.
    /// \note Changes to goals_ will also be seen by the heuristic.
    std::vector<State> &goals_;

    /// The goals that have already been found.
    std::vector<State> doneGoals_;

    /// The log of events generated by the search algorithm.
    Log &log_;

    /// Flag showing whether the search algorithm has accomplished its mission
    /// and should terminate.
    bool done_ = false;

    bool isDenied(Node *n) {
        auto oldCost = n->f;
        n->f = n->g + alg_.heuristic()(n);
        if (n->f > oldCost) {
            ++alg_.denied();
            log<Events::DeniedExpansion>(log_, n);
            alg_.oc().reInsert(n);
            return true;
        }
        log<Events::ResumedExpansion>(log_, n);
        return false;
    }

    void doneGoal(Node *n) {
        log<Events::SolvedGoal>(log_, n);
        log<Events::HideLast>(log_, n);
        CostType &res = alg_.res();
        res = (res * doneGoals_.size() + n->f) / (doneGoals_.size() + 1);
        doneGoals_.push_back(n->state());
        if (goals_.empty()) done_ = true;
    }
};

#endif

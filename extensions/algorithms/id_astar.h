#ifndef SLB_EXTENSIONS_ALGORITHMS_ID_ASTAR_H
#define SLB_EXTENSIONS_ALGORITHMS_ID_ASTAR_H

/// \file
/// \brief The \ref slb::ext::algorithm::IdAstar class.
/// \author Meir Goldenberg

#include "algorithm.h"

namespace slb {
namespace ext {
namespace algorithm {

// The symbols tool is currently not smart enough to take care of unused symbols
// that are templates.
template <class, bool> struct slb_tcb_nothing {};
#ifndef SLB_ID_ASTAR_BACKTRACK_LOCK
/// Default backtracking policy.
#define SLB_ID_ASTAR_BACKTRACK_LOCK slb_tcb_nothing
#endif

template <ALG_TPARAMS_NO_DEFAULTS, template <class, bool> class BacktrackLock,
          template <class> class Pruning>
struct IdAstar; // Forward declare for the following type traits to work.

/// The traits of \ref IdAstar.
/// \tparam logFlag If \c true, the events generated by the search algorithm are
/// logged. Otherwise, they are not.
/// \tparam Node_ The search node type.
/// \tparam GoalHandler The policy for handling goal conditions.
/// \tparam Heuristic The heuristic used by the search algorithm.
/// \tparam BacktrackLock The locking policy for backtracking.
template <ALG_TPARAMS_NO_DEFAULTS, template <class, bool> class BacktrackLock,
          template <class> class Pruning>
struct AlgorithmTraits<IdAstar<ALG_TARGS, BacktrackLock, Pruning>> {
    BASE_TRAITS_TYPES
    /// The search algorithm, \ref IdAstar in this case.
    using MyAlgorithm = IdAstar<ALG_TARGS, BacktrackLock, Pruning>;
};

#ifndef SLB_ID_ASTAR_PRUNING
/// The default pruning policy.
#define SLB_ID_ASTAR_PRUNING policy::pruning::Nothing
#endif

/// The \c IDA* search algorithm.
/// \tparam logFlag If \c true, the events generated by the search algorithm are
/// logged. Otherwise, they are not.
/// \tparam Node_ The search node type.
/// \tparam GoalHandler The policy for handling goal conditions.
/// \tparam InitialHeuristic The initial heuristic used by the search algorithm.
/// \tparam BacktrackLock The locking policy for backtracking.
/// \tparam Pruning The policy for pruning.
/// \note See the documentation for \ref ALG_TPARAMS and \ref ALG_DATA.
template <ALG_TPARAMS, template <class, bool> class BacktrackLock_ =
                           SLB_ID_ASTAR_BACKTRACK_LOCK,
          template <class> class Pruning = SLB_ID_ASTAR_PRUNING>
struct IdAstar : Algorithm<IdAstar<ALG_TARGS, BacktrackLock_>, ALG_TARGS> {
    BASE_TRAITS_TYPES

    /// The direct base.
    using DirectBase = Algorithm<IdAstar<ALG_TARGS, BacktrackLock_>, ALG_TARGS>;

    /// The goal handler policy.
    using GoalHandler = typename DirectBase::GoalHandler;

    /// The initial heuristic policy.
    using InitialHeuristic = typename DirectBase::InitialHeuristic;

    /// The generator policy.
    using Generator = typename DirectBase::Generator;

    /// Search neighbor type.
    using Neighbor = typename Generator::Neighbor;

    using MyType = IdAstar; ///< Required for \ref ALG_DATA symbol.

    /// The locking policy for backtracking.
    using BacktrackLock = BacktrackLock_<MyType, logFlag_>;

    ALG_DATA

    /// Initializes the algorithm based on the problem instance.
    /// \param instance The problem instance.
    IdAstar(const MyInstance &instance)
        : Base(instance), cur_{new Node(start_)}, pruner_(*this) {
        if (!BacktrackLock::keepsParent) cur_->setParent(cur_.get());
    }

    /// Runs the algorithm.
    /// \return The solution cost. If there is no solution, then \c CostType{-1}
    /// is returned.
    ReturnType run() {
        TimerLock lock{time_}; (void)lock;
        threshold_ = initialHeuristic_(cur_.get());
        cur_->set(0, threshold_, this->stamp());
        log<ext::event::MarkedStart>(log_, cur_.get());
        goalHandler_.logInit();

        while (true) {
            next_threshold_ = std::numeric_limits<CostType>::max();
            int gen_before = generated_.value(); (void)gen_before;
            bool iterationResult = iteration();
            // std::cout << threshold_ << " " << std::fixed
            //            << generated_.value() - gen_before << std::endl;
            if (iterationResult) break;
            threshold_ = next_threshold_;
        }

        cost_.set(res_);
        return res_;
    }

    /// Performs a single iteration of IDA*.
    /// \return \c true if the solution has been found and \c false otherwise.
    bool iteration() {
        if (!Generator::Heuristic::dynamic && thresholdCut_())
            return false;

        log<ext::event::Selected>(log_, cur_);
        goalHandler_.onSelect();
        if (goalHandler_.done())
            return true;

        ++expanded_;
        // generator_.successors may return reference to pre-computed vector of
        // neighbors, hence need decltype.
        using SuccessorsType = decltype(generator_.successors(cur_->state()));
        SuccessorsType neighbors_ = generator_.successors(cur_->state());
        for (auto &n : neighbors_) {
            if (pruner_(n)) continue;
            ++generated_;
            CostType newH;
            if (!Generator::Heuristic::dynamic || !thresholdCut_(n, newH)) {
                BacktrackLock btLock{*this, n, newH};
                BacktrackLock *prevLock_ = lastLock_;
                lastLock_ = &btLock;
                auto itRes = iteration();
                lastLock_ = prevLock_;
                if (itRes) return true;
            }
        }
        log<ext::event::Closed>(log_, cur_);
        return false;
    }

    /// \name Services for policies.
    /// @{
    Node *cur() { return &*cur_; }
    const BacktrackLock *const &lastLock() const { return lastLock_; }
    BacktrackLock *&lastLock() { return lastLock_; }
    /// @}
private:
    std::unique_ptr<Node> cur_; ///< The currently selected node.
    BacktrackLock *lastLock_ = nullptr; ///< The last btLock. Set by the lock;
    Pruning<MyType> pruner_; ///< The pruning policy.
    CostType threshold_; ///< The current iteration's cost threshold.
    CostType next_threshold_; ///< The cost threshold for the next iteration.

    /// Checks whether the threshold is exceeded for the case of non-dynamic
    /// heuristic. If so, updates the next threshold.
    /// \return \c true if the threshold is exceeded and \c false otherwise.
    bool thresholdCut_() {
        if (cur_->f > threshold_) {
            next_threshold_ = std::min(next_threshold_, cur_->f);
            return true;
        }
        return false;
    }

    /// Checks whether the threshold is exceeded for the case of dynamic
    /// heuristic. If so, updates the next threshold.
    /// \param n The current neighbor.
    /// \param newH The heuristic value corresponding to \c n.
    /// \return \c true if the threshold is exceeded and \c false otherwise.
    bool thresholdCut_(const Neighbor &n, CostType &newH) {
        newH = this->generator_.heuristic(n, cur_.get());
        CostType newF = cur_->g + n.cost() + newH;
        if (newF > threshold_) {
            next_threshold_ = std::min(next_threshold_, newF);
            return true;
        }
        return false;
    }
};

} // namespace
} // namespace
} // namespace

#endif

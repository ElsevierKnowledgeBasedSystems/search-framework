#ifndef SLB_EXTENSIONS_ALGORITHMS_UNIFORM_COST_H
#define SLB_EXTENSIONS_ALGORITHMS_UNIFORM_COST_H

/// \file
/// \brief The \ref slb::ext::algorithm::UniformCost class.
/// \author Meir Goldenberg

#include "astar.h"

namespace slb {
namespace ext {
namespace algorithm {

/// The search node type for the uniform-cost search.
using UniformNode = slb::core::sb::SearchNode<>;

/// The open list type for the uniform-cost search.
/// \tparam MyAlgorithm The search algorithm.
template <class MyAlgorithm>
using UniformOL = ext::policy::openList::BucketedStdMap_T<
    MyAlgorithm, UniformNode, ext::policy::openList::DefaultOLKeyType,
    ext::policy::openList::GreaterPriority_SmallG,
    ext::policy::openList::OLMap>;

/// The heuristic type for the uniform-cost search.
/// \tparam MyAlgorithm The search algorithm.
template <class MyAlgorithm>
using UniformHeuristic = ext::policy::heuristic::Zero<MyAlgorithm>;

/// The node generator for the uniform-cost search.
/// \tparam MyAlgorithm The search algorithm.
template <class MyAlgorithm>
using UniformGenerator =
    ext::policy::generator::StatesT<MyAlgorithm, UniformHeuristic>;

/// The uniform-cost search algorithm.
/// \tparam logFlag_ If \c true, the events generated by the search algorithm
/// are logged. Otherwise, they are not.
/// \tparam GoalHandler The policy for handling goal conditions.
/// \note The algorithm is defined as a struct rather than as an alias to allow
/// forward declarations.
template <bool logFlag, template <class> class GoalHandler = SLB_GOAL_HANDLER>
struct UniformCost : Astar<logFlag, UniformNode, GoalHandler, UniformHeuristic,
                           UniformGenerator, UniformOL> {
    /// The direct base, which is \ref Astar in this case.
    using MyBase = Astar<logFlag, UniformNode, GoalHandler, UniformHeuristic,
                         UniformGenerator, UniformOL>;
    using MyBase::Astar;
};

/// The simple version of uniform-cost search algorithm, where no logging is
/// done and there is no goal state, so that the whole domain is explored.
/// \note The algorithm is defined as a struct rather than as an alias to allow
/// forward declarations.
struct SimpleUniformCost
    : UniformCost<false, ext::policy::goalHandler::NoGoal> {
    /// The direct base, which is \ref UniformCost in this case.
    using MyBase = UniformCost<false, ext::policy::goalHandler::NoGoal>;

    /// The Astar algorithm type.
    using Astar = MyBase::MyBase;
    using MyBase::UniformCost;
    using MyBase::distanceMap;

    /// The state type, represents the domain.
    using State = Astar::State;

    /// The problem instance type.
    using MyInstance = Astar::MyInstance;

    /// The type for storing distances from other states to the start state.
    using DistanceMap = Astar::DistanceMap;

    /// Computes the distances from other states to the given state.
    /// \return The distances from other states to \c s.
    static DistanceMap distanceMap(const State &s) {
        auto instance = MyInstance(std::vector<State>{s}, std::vector<State>(1),
                                   MeasureSet{});
        SimpleUniformCost search(instance);
        search.run();
        return search.distanceMap();
    }
};

} // namespace
} // namespace
} // namespace

#endif

#ifndef ALOGORITHM_H
#define ALOGORITHM_H

/// \file
/// \brief The \ref Algorithm class.
/// \author Meir Goldenberg

/// Common template parameters for search algorithms.
// See http://stackoverflow.com/q/34130672/2725810 for the discussion of
// the use of template template parameters.
#define ALG_TPARAMS bool logFlag, class Node_ = SLB_NODE, \
        template <class> class GoalHandler = SLB_GOAL_HANDLER,   \
        class Heuristic = SLB_HEURISTIC

/// Same as \ref ALG_TPARAMS, but without default values; needed for partial
/// specializations of AlgorithmTraits.
#define ALG_TPARAMS_NO_DEFAULTS                                                \
    bool logFlag, class Node_, template <class>                                \
                               class GoalHandler, class Heuristic

/// Template arguments to be used for inheriting from \ref Algorithm.
#define ALG_TARGS logFlag, Node_, GoalHandler, Heuristic

/// Type aliases to be defined by all search algorithms. See the documentation
/// for these aliases inside the \ref Algorithm class.
#define BASE_TRAITS_TYPES                                                      \
    using Traits = BaseTraits<ALG_TARGS>;                                      \
    using Node = typename Traits::Node;                                        \
    using NodeData = typename Traits::NodeData;                                \
    using CostType = typename Traits::CostType;                                \
    using NodeUniquePtr = typename Traits::NodeUniquePtr;                      \
    using State = typename Traits::State;                                      \
    using MyInstance = typename Traits::MyInstance;                            \
    using Neighbor = typename Traits::Neighbor;                                \
    using MyAlgorithmLog = typename Traits::MyAlgorithmLog;

/// Data members of \ref Algorithm to be used by all search algorithms.
#define ALG_DATA                                                               \
    using Base = Algorithm<MyType, ALG_TARGS>;                                 \
    using Base::log_;                                                          \
    using Base::instance_;                                                     \
    using Base::start_;                                                        \
    using Base::goalHandler_;                                                  \
    using Base::heuristic_;                                                    \
    using Base::expanded_;                                                     \
    using Base::generated_;                                                    \
    using Base::time_;                                                         \
    using Base::cost_;

template <ALG_TPARAMS>
struct BaseTraits {
    /// The search node type.
    using Node = Node_;

    /// The type of data stored with a search node.
    using NodeData = typename Node::NodeData;

    /// Type for action cost in the search domain.
    using CostType = typename Node::CostType;

    /// Unique pointer to search node.
    using NodeUniquePtr = typename Node::NodeUniquePtr;

    /// The state type, represents the domain.
    using State = typename Node::State;

    /// The problem instance type.
    using MyInstance = Instance<State>;

    /// The type for a single neighbor of a given state.
    using Neighbor = typename State::Neighbor;

    /// The type for the log of events generated by the algorithm.
    using MyAlgorithmLog =
        typename std::conditional<logFlag, AlgorithmLog<Node>, Nothing>::type;
};

/// Common abstract base for search algorithms.
/// \tparam logFlag If \c true, the events generated by the search algorithm are
/// logged. Otherwise, they are not.
/// \tparam Node_ The search node type.
/// \tparam GoalHandler The policy for handling goal conditions.
/// \tparam Heuristic The heuristic used by the search algorithm.
template <class Concrete, ALG_TPARAMS>
struct Algorithm {
    BASE_TRAITS_TYPES

    /// Returns the statistics about the search algorithm's
    /// performance for solving the particular instance.
    /// \return The statistics about the search algorithm's
    /// performance for solving the particular instance.
    MeasureSet measures() const {
        return {time_, cost_, expanded_, generated_};
    }

    /// Returns the log of events generated by the search algorithm.
    /// \return Const reference to the log of events generated by the search
    /// algorithm.
    MyAlgorithmLog &log() { return log_; }

    /// \name Services for policies.
    /// @{

    MyInstance &instance() { return instance_; }

    /// @}
protected:
    /// Initializes the algorithm based on the problem instance.
    /// \param instance The problem instance.
    Algorithm(MyInstance &instance)
        : instance_(instance), start_(instance_.start()),
          goalHandler_(static_cast<Concrete &>(*this)), heuristic_(instance_) {}

    MyInstance instance_; ///< The problem instance.

    /// The log of events generated by the search algorithm.
    MyAlgorithmLog log_;

    /// The start state (multiple start states are to be handled in the future).
    State start_;

    /// The policy for handling conditions related to goal states.
    GoalHandler<Concrete> goalHandler_;

    /// The heuristic used by the search algorithm.
    Heuristic heuristic_;

    /// \name Statistics about the search algorithm's performance.
    /// \note These statistics pertain to solving the particular instance.
    /// @{

    /// The number of nodes expanded by the search algorithm.
    Measure expanded_{"Expanded"};

    /// The number of nodes generated by the search algorithm.
    Measure generated_{"Generated"};

    /// Time taken by the search algorithm.
    Timer time_{"Time (ms.)"};

    /// The cost of the solution.
    Measure cost_{"Cost"};
    /// @}
};

#endif

\subsection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ActionNeighbor}{slb\+::core\+::sb\+::\+Action\+Neighbor$<$ State\+\_\+, uniform\+Flag $>$} \\*The type for an action neighbor of a given state }{\pageref{structslb_1_1core_1_1sb_1_1ActionNeighbor}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1generator_1_1ActionsT}{slb\+::ext\+::policy\+::generator\+::\+Actions\+T$<$ My\+Algorithm, Heuristic $>$} \\*Generator that generates action neighbors }{\pageref{structslb_1_1ext_1_1policy_1_1generator_1_1ActionsT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1Algorithm}{slb\+::ext\+::algorithm\+::\+Algorithm$<$ Concrete, A\+L\+G\+\_\+\+T\+P\+A\+R\+A\+M\+S $>$} \\*Abstract base for search algorithms }{\pageref{structslb_1_1ext_1_1algorithm_1_1Algorithm}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1AlgorithmLog}{slb\+::core\+::ui\+::\+Algorithm\+Log$<$ Node $>$} \\*The log of events generated by an algorithm }{\pageref{structslb_1_1core_1_1ui_1_1AlgorithmLog}}{}
\item\contentsline{section}{\hyperlink{classslb_1_1ext_1_1algorithm_1_1AlgorithmTraits}{slb\+::ext\+::algorithm\+::\+Algorithm\+Traits$<$ My\+Algorithm $>$} \\*Types associated with concrete algorithms. See also \href{http://stackoverflow.com/questions/8401827/crtp-and-type-visibility}{\tt http\+://stackoverflow.\+com/questions/8401827/crtp-\/and-\/type-\/visibility} }{\pageref{classslb_1_1ext_1_1algorithm_1_1AlgorithmTraits}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1AlgorithmTraits_3_01ext_1_1algorithm_1_1Astar_3_01ALG__TARGS_00_01Open_01_4_01_4}{slb\+::ext\+::algorithm\+::\+Algorithm\+Traits$<$ ext\+::algorithm\+::\+Astar$<$ A\+L\+G\+\_\+\+T\+A\+R\+G\+S, Open $>$ $>$} \\*The traits of \hyperlink{structslb_1_1ext_1_1algorithm_1_1Astar}{Astar} }{\pageref{structslb_1_1ext_1_1algorithm_1_1AlgorithmTraits_3_01ext_1_1algorithm_1_1Astar_3_01ALG__TARGS_00_01Open_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1AlgorithmTraits_3_01IdAstar_3_01ALG__TARGS_00_01BacktrackLock_00_01Pruning_01_4_01_4}{slb\+::ext\+::algorithm\+::\+Algorithm\+Traits$<$ Id\+Astar$<$ A\+L\+G\+\_\+\+T\+A\+R\+G\+S, Backtrack\+Lock, Pruning $>$ $>$} \\*The traits of \hyperlink{structslb_1_1ext_1_1algorithm_1_1IdAstar}{Id\+Astar} }{\pageref{structslb_1_1ext_1_1algorithm_1_1AlgorithmTraits_3_01IdAstar_3_01ALG__TARGS_00_01BacktrackLock_00_01Pruning_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1AllMenus}{slb\+::core\+::ui\+::\+All\+Menus$<$ Node $>$} \\*A holder for all the menus with an indicator of which menu and form are currently active }{\pageref{structslb_1_1core_1_1ui_1_1AllMenus}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1Astar}{slb\+::ext\+::algorithm\+::\+Astar$<$ A\+L\+G\+\_\+\+T\+P\+A\+R\+A\+M\+S, Open\+\_\+ $>$} \\*The {\ttfamily A$\ast$} search algorithm }{\pageref{structslb_1_1ext_1_1algorithm_1_1Astar}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1instanceMeasure_1_1Base}{slb\+::ext\+::instance\+Measure\+::\+Base} \\*One instance measure -- the cost }{\pageref{structslb_1_1ext_1_1instanceMeasure_1_1Base}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1commandLine_1_1Base}{slb\+::core\+::command\+Line\+::\+Base} \\*Holds the command line object. This is needed to initialize the command line object before it is passed to the additions }{\pageref{structslb_1_1core_1_1commandLine_1_1Base}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1node_1_1BaseT}{slb\+::ext\+::node\+::\+Base\+T$<$ State $>$} \\*Regular node storing {\ttfamily g} and {\ttfamily f} }{\pageref{structslb_1_1ext_1_1node_1_1BaseT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1BaseTraits}{slb\+::ext\+::algorithm\+::\+Base\+Traits$<$ A\+L\+G\+\_\+\+T\+P\+A\+R\+A\+M\+S $>$} \\*Traits shared by all algorithms }{\pageref{structslb_1_1ext_1_1algorithm_1_1BaseTraits}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1BasicInformedIterator}{slb\+::core\+::util\+::\+Basic\+Informed\+Iterator$<$ Container, Base $>$} \\*Adapter for iterator that knows whether it is at the end }{\pageref{structslb_1_1core_1_1util_1_1BasicInformedIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1BasicVectorSkipIterator}{slb\+::core\+::util\+::\+Basic\+Vector\+Skip\+Iterator$<$ My\+Vector, Base\+Iterator $>$} \\*Skipping iterators for a vector. Use the aliases defined below }{\pageref{structslb_1_1core_1_1util_1_1BasicVectorSkipIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1openList_1_1BucketedStdMap__T}{slb\+::ext\+::policy\+::open\+List\+::\+Bucketed\+Std\+Map\+\_\+\+T$<$ My\+Algorithm\+\_\+, Node\+\_\+, Key\+Type\+\_\+, Greater\+Priority\+\_\+, Container $>$} \\*A flexible open list base on {\ttfamily std\+::map} whose values are buckets of nodes with same priority }{\pageref{structslb_1_1ext_1_1policy_1_1openList_1_1BucketedStdMap__T}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1gu_1_1Circle}{slb\+::core\+::util\+::gu\+::\+Circle} \\*The circle }{\pageref{structslb_1_1core_1_1util_1_1gu_1_1Circle}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1Closed}{slb\+::ext\+::event\+::\+Closed$<$ Node $>$} \\*Event that visualizes having closed a node }{\pageref{structslb_1_1ext_1_1event_1_1Closed}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1CommandLine}{slb\+::ext\+::heuristic\+::differential\+::\+Command\+Line} \\*Additions to the command line related to the differential heuristic }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1CommandLine}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1commandLine_1_1CommandLine}{slb\+::core\+::command\+Line\+::\+Command\+Line$<$ Additions $>$} \\*Class handling the command line. It is singleton. The command line would usually be accessed from the other code using the \hyperlink{command__line_8h_a0a5ceb9ceb914e08d345410b561cb37a}{C\+MD} macro }{\pageref{structslb_1_1core_1_1commandLine_1_1CommandLine}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1CommandLine}{slb\+::ext\+::domain\+::pancake\+::\+Command\+Line} \\*Additions to the command line related to the \hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1Pancake}{Pancake} puzzle domain }{\pageref{structslb_1_1ext_1_1domain_1_1pancake_1_1CommandLine}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1incWorst_1_1CommandLine}{slb\+::ext\+::domain\+::inc\+Worst\+::\+Command\+Line} \\*Additions to the command line related to the Pancake puzzle domain }{\pageref{structslb_1_1ext_1_1domain_1_1incWorst_1_1CommandLine}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Copy}{slb\+::ext\+::policy\+::backtrack\+Lock\+::\+Copy$<$ My\+Algorithm, bool $>$} \\*A class for handling R\+A\+II for backtracking in I\+D\+A$\ast$ when the parent state is kept, i.\+e. \hyperlink{structslb_1_1core_1_1sb_1_1StateNeighbor}{core\+::sb\+::\+State\+Neighbor} (i.\+e. not \hyperlink{structslb_1_1core_1_1sb_1_1ActionNeighbor}{core\+::sb\+::\+Action\+Neighbor}) is used. The second template parameter is not used, just for uniformity }{\pageref{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Copy}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1Cost}{slb\+::core\+::sb\+::\+Cost$<$ State\+\_\+, uniform\+Flag $>$} \\*The type for storing the cost of a neighbor }{\pageref{structslb_1_1core_1_1sb_1_1Cost}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1Cost_3_01State___00_01true_01_4}{slb\+::core\+::sb\+::\+Cost$<$ State\+\_\+, true $>$} \\*Specialization of the type for storing the cost of a neighbor for uniform domains }{\pageref{structslb_1_1core_1_1sb_1_1Cost_3_01State___00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1instanceMeasure_1_1CostGoal0Goal1}{slb\+::ext\+::instance\+Measure\+::\+Cost\+Goal0\+Goal1} \\*One additional instance measure -- the distance between the first two goals }{\pageref{structslb_1_1ext_1_1instanceMeasure_1_1CostGoal0Goal1}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1CurrentStyles}{slb\+::core\+::ui\+::\+Current\+Styles$<$ State $>$} \\*A class for storing the current styles of vertices and edges in the visual representation }{\pageref{structslb_1_1core_1_1ui_1_1CurrentStyles}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1openList_1_1DefaultOLKeyType}{slb\+::ext\+::policy\+::open\+List\+::\+Default\+O\+L\+Key\+Type$<$ Node $>$} \\*Nodes are ordered in the open list based on g and f. The particular ordering rules are defined by the other policies }{\pageref{structslb_1_1ext_1_1policy_1_1openList_1_1DefaultOLKeyType}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1DeniedExpansion}{slb\+::ext\+::event\+::\+Denied\+Expansion$<$ Node $>$} \\*Event that visualizes a node\textquotesingle{}s expansion being denied following suspension (see \hyperlink{structslb_1_1ext_1_1event_1_1SuspendedExpansion}{Suspended\+Expansion}) }{\pageref{structslb_1_1ext_1_1event_1_1DeniedExpansion}}{}
\item\contentsline{section}{\hyperlink{classslb_1_1core_1_1util_1_1deref__shared__ptr}{slb\+::core\+::util\+::deref\+\_\+shared\+\_\+ptr$<$ T $>$} \\*Shared pointer whose {\ttfamily operator==} compares the pointed to values }{\pageref{classslb_1_1core_1_1util_1_1deref__shared__ptr}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap}{slb\+::ext\+::heuristic\+::differential\+::\+Distance\+Map$<$ State, Index, kind $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1noInverse_01_4}{slb\+::ext\+::heuristic\+::differential\+::\+Distance\+Map$<$ State, Index, Index\+Kind\+::no\+Inverse $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1noInverse_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1none_01_4}{slb\+::ext\+::heuristic\+::differential\+::\+Distance\+Map$<$ State, Index, Index\+Kind\+::none $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1none_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1withInverse_01_4}{slb\+::ext\+::heuristic\+::differential\+::\+Distance\+Map$<$ State, Index, Index\+Kind\+::with\+Inverse $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistanceMap_3_01State_00_01Index_00_01IndexKind_1_1withInverse_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistancesToPivots}{slb\+::ext\+::heuristic\+::differential\+::\+Distances\+To\+Pivots$<$ State, Index, k $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistancesToPivots}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistancesToPivots_3_01State_00_01Index_00_01IndexKind_1_1none_01_4}{slb\+::ext\+::heuristic\+::differential\+::\+Distances\+To\+Pivots$<$ State, Index, Index\+Kind\+::none $>$} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1DistancesToPivots_3_01State_00_01Index_00_01IndexKind_1_1none_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1DomainBase}{slb\+::core\+::sb\+::\+Domain\+Base} \\*A type for common features of domains }{\pageref{structslb_1_1core_1_1sb_1_1DomainBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1Drawer}{slb\+::core\+::ui\+::\+Drawer$<$ Node $>$} \\*Draws the (partial) domain graph with given styles for visual representation of vertices and edges }{\pageref{structslb_1_1core_1_1ui_1_1Drawer}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1DynamicGapHeuristic}{slb\+::ext\+::domain\+::pancake\+::\+Dynamic\+Gap\+Heuristic} \\*Functor for computing the dynamic gap heuristic to the goal state with ordered pancakes }{\pageref{structslb_1_1ext_1_1domain_1_1pancake_1_1DynamicGapHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1DynamicMDHeuristic}{slb\+::ext\+::domain\+::sliding\+\_\+tile\+::\+Dynamic\+M\+D\+Heuristic} \\*Functor for computing the dynamic Manhattan distance heuristic to the goal state with ordered pancakes and blank at position 0 }{\pageref{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1DynamicMDHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1heuristic_1_1DynamicSingleGoalT}{slb\+::ext\+::policy\+::heuristic\+::\+Dynamic\+Single\+Goal\+T$<$ My\+Algorithm, Base\+Heuristic $>$} \\*Dynamic heuristic to single goal }{\pageref{structslb_1_1ext_1_1policy_1_1heuristic_1_1DynamicSingleGoalT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EventBase_1_1EdgeChange}{slb\+::core\+::ui\+::\+Event\+Base$<$ Node $>$\+::\+Edge\+Change} \\*Description of change of visual representation of an edge. An edge is represented here by a pair of smart pointers to states. Note that this is different from a visual event (see \hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent_1_1EdgeChange}{Visual\+Event\+::\+Edge\+Change}), in which an edge is represented here by a pair of vertices of the domain graph }{\pageref{structslb_1_1core_1_1ui_1_1EventBase_1_1EdgeChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent_1_1EdgeChange}{slb\+::core\+::ui\+::\+Visual\+Event$<$ State $>$\+::\+Edge\+Change} \\*Description of change of visual representation of a single edge }{\pageref{structslb_1_1core_1_1ui_1_1VisualEvent_1_1EdgeChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EdgeStyle}{slb\+::core\+::ui\+::\+Edge\+Style} \\*Visualization properties for a single directed edge }{\pageref{structslb_1_1core_1_1ui_1_1EdgeStyle}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EditField}{slb\+::core\+::ui\+::\+Edit\+Field} \\*Implements a simple text edit field }{\pageref{structslb_1_1core_1_1ui_1_1EditField}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1EnteredOpen}{slb\+::ext\+::event\+::\+Entered\+Open$<$ Node $>$} \\*Event that visualizes a node entering the Open List }{\pageref{structslb_1_1ext_1_1event_1_1EnteredOpen}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EventBase}{slb\+::core\+::ui\+::\+Event\+Base$<$ Node $>$} \\*The base class for the events generated by the search algorithm. Note that an event carries with it the information about its visualization as well. This information is the basis for building a visual event (\hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent}{Visual\+Event}) out of it }{\pageref{structslb_1_1core_1_1ui_1_1EventBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ExplicitState}{slb\+::core\+::sb\+::\+Explicit\+State$<$ Explicit\+Space $>$} \\*The base class for a state in an explicit domain. It can be viewed as a wrapper for the location type defined by the explicit domain }{\pageref{structslb_1_1core_1_1sb_1_1ExplicitState}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1Filter}{slb\+::core\+::ui\+::\+Filter$<$ Node $>$} \\*Composite filter. Does not filter out only the events not filtered out by any of the constituent filters }{\pageref{structslb_1_1core_1_1ui_1_1Filter}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1FilterBase}{slb\+::core\+::ui\+::\+Filter\+Base$<$ Node $>$} \\*The abstract base for all filters }{\pageref{structslb_1_1core_1_1ui_1_1FilterBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1FilterEventStr}{slb\+::core\+::ui\+::\+Filter\+Event\+Str$<$ Node $>$} \\*Filters based on description strings of events }{\pageref{structslb_1_1core_1_1ui_1_1FilterEventStr}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1FilterState}{slb\+::core\+::ui\+::\+Filter\+State$<$ Node $>$} \\*Filters by leaving only events related to chosen states. When the list of states is empty, no events are filtered out }{\pageref{structslb_1_1core_1_1ui_1_1FilterState}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1Form}{slb\+::core\+::ui\+::\+Form} \\*A simple form for ncurses. Forms that come with {\ttfamily ncurses} cannot be put in pad windows }{\pageref{structslb_1_1core_1_1ui_1_1Form}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1Furthest}{slb\+::ext\+::heuristic\+::differential\+::\+Furthest} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1Furthest}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1GapHeuristic}{slb\+::ext\+::domain\+::pancake\+::\+Gap\+Heuristic} \\*Functor for computing the gap heuristic to the goal state with ordered pancakes }{\pageref{structslb_1_1ext_1_1domain_1_1pancake_1_1GapHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1GapHeuristicToGoal}{slb\+::ext\+::domain\+::pancake\+::\+Gap\+Heuristic\+To\+Goal} \\*Functor for computing the gap heuristic to the given goal state }{\pageref{structslb_1_1ext_1_1domain_1_1pancake_1_1GapHeuristicToGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1Generated}{slb\+::ext\+::event\+::\+Generated$<$ Node $>$} \\*Event that visualizes node generation }{\pageref{structslb_1_1ext_1_1event_1_1Generated}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1Graphics}{slb\+::core\+::ui\+::\+Graphics} \\*Objects of this class hold all the information needed for drawing }{\pageref{structslb_1_1core_1_1ui_1_1Graphics}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1openList_1_1GreaterPriority__SmallF__LargeG}{slb\+::ext\+::policy\+::open\+List\+::\+Greater\+Priority\+\_\+\+Small\+F\+\_\+\+Large\+G$<$ Key\+Type $>$} \\*Functor that compares keys based on f-\/value and breaks ties in favor of larger g-\/value }{\pageref{structslb_1_1ext_1_1policy_1_1openList_1_1GreaterPriority__SmallF__LargeG}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1openList_1_1GreaterPriority__SmallG}{slb\+::ext\+::policy\+::open\+List\+::\+Greater\+Priority\+\_\+\+Small\+G$<$ Key\+Type $>$} \\*Functor that compares keys based on g-\/value and prioritizes in favor of a smaller g-\/value }{\pageref{structslb_1_1ext_1_1policy_1_1openList_1_1GreaterPriority__SmallG}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1explicit__space_1_1Grid}{slb\+::ext\+::explicit\+\_\+space\+::\+Grid$<$ Cost\+Type\+\_\+ $>$} \\*The type for 4 or 8-\/connected grid explicit domain }{\pageref{structslb_1_1ext_1_1explicit__space_1_1Grid}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1grid_1_1Grid}{slb\+::ext\+::domain\+::grid\+::\+Grid$<$ Cost\+Type, uniform\+Flag $>$} \\*Explicit state specific to the \hyperlink{structslb_1_1ext_1_1domain_1_1grid_1_1Grid}{Grid} Map domain }{\pageref{structslb_1_1ext_1_1domain_1_1grid_1_1Grid}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1GroupLock}{slb\+::core\+::ui\+::\+Group\+Lock} \\*A \hyperlink{structslb_1_1core_1_1ui_1_1GroupLock}{Group\+Lock} object is created in order that the following drawing is done in a group, possibly on top of the current drawing. ~\newline
It cares for a lot of nitty-\/gritty details without which strange things happen. ~\newline
Uses \hyperlink{structslb_1_1core_1_1ui_1_1PatternLock}{Pattern\+Lock} to implement its functionality }{\pageref{structslb_1_1core_1_1ui_1_1GroupLock}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1H}{slb\+::ext\+::heuristic\+::differential\+::\+H$<$ State, Base\+Heuristic, Placement, Index\+With\+Inverse, Compact\+Index $>$} \\*The differential heuristic. Specializations are for particular placements }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1H}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1H_3_01State_00_01BaseHeuristic_00_01Furthest_0071671274a92eae86902a47a514057667}{slb\+::ext\+::heuristic\+::differential\+::\+H$<$ State, Base\+Heuristic, Furthest, Index\+With\+Inverse, Compact\+Index $>$} \\*The differential heuristic with the furthest placement }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1H_3_01State_00_01BaseHeuristic_00_01Furthest_0071671274a92eae86902a47a514057667}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1has__layout}{slb\+::core\+::ui\+::has\+\_\+layout$<$ State, typename $>$} \\*Declared only if {\ttfamily State} does not have a function for computing layout }{\pageref{structslb_1_1core_1_1ui_1_1has__layout}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1HBase}{slb\+::ext\+::heuristic\+::differential\+::\+H\+Base$<$ State, Base\+Heuristic, Index $>$} \\*The differential heuristic }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1HBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1HideLast}{slb\+::ext\+::event\+::\+Hide\+Last$<$ Node $>$} \\*Event that cancels the visual effect of the previous event }{\pageref{structslb_1_1ext_1_1event_1_1HideLast}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1IdAstar}{slb\+::ext\+::algorithm\+::\+Id\+Astar$<$ A\+L\+G\+\_\+\+T\+P\+A\+R\+A\+M\+S, Backtrack\+Lock\+\_\+, Pruning $>$} \\*The {\ttfamily I\+D\+A$\ast$} search algorithm }{\pageref{structslb_1_1ext_1_1algorithm_1_1IdAstar}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1incWorst_1_1IncWorst}{slb\+::ext\+::domain\+::inc\+Worst\+::\+Inc\+Worst} \\*The worst case example for an inconsistent heuristics }{\pageref{structslb_1_1ext_1_1domain_1_1incWorst_1_1IncWorst}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1IndexIterator}{slb\+::core\+::util\+::\+Index\+Iterator$<$ My\+Vector, Base $>$} }{\pageref{structslb_1_1core_1_1util_1_1IndexIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Inplace}{slb\+::ext\+::policy\+::backtrack\+Lock\+::\+Inplace$<$ My\+Algorithm, bool $>$} \\*Handles R\+A\+II for backtracking in I\+D\+A$\ast$ when the state is updated in place }{\pageref{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Inplace}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Inplace_3_01MyAlgorithm_00_01true_01_4}{slb\+::ext\+::policy\+::backtrack\+Lock\+::\+Inplace$<$ My\+Algorithm, true $>$} \\*Handles R\+A\+II for backtracking in I\+D\+A$\ast$ when the state is updated in place and log is kept, so that a copy of the parent state needs to be kept }{\pageref{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1Inplace_3_01MyAlgorithm_00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1InplaceBase}{slb\+::ext\+::policy\+::backtrack\+Lock\+::\+Inplace\+Base$<$ My\+Algorithm $>$} \\*Base for a class handling R\+A\+II for backtracking in I\+D\+A$\ast$ when the state is updated in place (i.\+e. \hyperlink{structslb_1_1core_1_1sb_1_1ActionNeighbor}{core\+::sb\+::\+Action\+Neighbor} is used) }{\pageref{structslb_1_1ext_1_1policy_1_1backtrackLock_1_1InplaceBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1Instance}{slb\+::core\+::sb\+::\+Instance$<$ State\+\_\+ $>$} \\*The type for an instance with an arbitrary (but fixed) number of start and goal states }{\pageref{structslb_1_1core_1_1sb_1_1Instance}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1LayoutTolerance}{slb\+::core\+::ui\+::\+Layout\+Tolerance} \\*Like boost\textquotesingle{}s {\ttfamily layout\+\_\+tolerance$<$double$>$}, but accepting a time limit as well }{\pageref{structslb_1_1core_1_1ui_1_1LayoutTolerance}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1goalHandler_1_1LazyUpdate}{slb\+::ext\+::policy\+::goal\+Handler\+::\+Lazy\+Update$<$ My\+Algorithm $>$} \\*Handling conditions related to goal states for the case when there are multiple goal states and a heuristic that stores the goal state responsible for the heuristic value is used }{\pageref{structslb_1_1ext_1_1policy_1_1goalHandler_1_1LazyUpdate}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1LogWindow}{slb\+::core\+::ui\+::\+Log\+Window$<$ Node $>$} \\*Textual window the provides functionality for analyzing the log generated by the search algorithm }{\pageref{structslb_1_1core_1_1ui_1_1LogWindow}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode}{slb\+::core\+::sb\+::\+Managed\+Node$<$ Base1\+\_\+, Base2\+\_\+, Base3\+\_\+, Base4\+\_\+, Base5\+\_\+ $>$} \\*A node endowed with \href{http://stackoverflow.com/a/11744832/2725810}{\tt reflection capabilities}. In particular universal output operators are defined for such a node }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01Base3___00_01Base4___01_4}{slb\+::core\+::sb\+::\+Managed\+Node$<$ Base1\+\_\+, Base2\+\_\+, Base3\+\_\+, Base4\+\_\+ $>$} \\*Note that inherits data from four base classes }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01Base3___00_01Base4___01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01Base3___00_01void_01_4}{slb\+::core\+::sb\+::\+Managed\+Node$<$ Base1\+\_\+, Base2\+\_\+, Base3\+\_\+, void $>$} \\*Note that inherits data from three base classes }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01Base3___00_01void_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01void_00_01void_01_4}{slb\+::core\+::sb\+::\+Managed\+Node$<$ Base1\+\_\+, Base2\+\_\+, void, void $>$} \\*Note that inherits data from two base classes }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01Base2___00_01void_00_01void_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01void_00_01void_00_01void_01_4}{slb\+::core\+::sb\+::\+Managed\+Node$<$ Base1\+\_\+, void, void, void $>$} \\*Note that inherits data from a single base class }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode_3_01Base1___00_01void_00_01void_00_01void_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1ManagedNode_3_01void_00_01void_00_01void_00_01void_01_4}{slb\+::core\+::sb\+::\+Managed\+Node$<$ void, void, void, void $>$} \\*Node that does not inherit data }{\pageref{structslb_1_1core_1_1sb_1_1ManagedNode_3_01void_00_01void_00_01void_00_01void_01_4}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1grid_1_1ManhattanHeuristic}{slb\+::ext\+::domain\+::grid\+::\+Manhattan\+Heuristic$<$ State $>$} \\*The Manhattan heuristic functor }{\pageref{structslb_1_1ext_1_1domain_1_1grid_1_1ManhattanHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1MapKeyConstIterator}{slb\+::core\+::util\+::\+Map\+Key\+Const\+Iterator$<$ My\+Map $>$} \\*Const iterator over keys of a map }{\pageref{structslb_1_1core_1_1util_1_1MapKeyConstIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1MapKeyIterator}{slb\+::core\+::util\+::\+Map\+Key\+Iterator$<$ My\+Map $>$} \\*Iterator over keys of a map }{\pageref{structslb_1_1core_1_1util_1_1MapKeyIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1MapValConstIterator}{slb\+::core\+::util\+::\+Map\+Val\+Const\+Iterator$<$ My\+Map $>$} \\*Const iterator over values of a map }{\pageref{structslb_1_1core_1_1util_1_1MapValConstIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1MapValIterator}{slb\+::core\+::util\+::\+Map\+Val\+Iterator$<$ My\+Map $>$} \\*Iterator over values of a map }{\pageref{structslb_1_1core_1_1util_1_1MapValIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1MarkedGoal}{slb\+::ext\+::event\+::\+Marked\+Goal$<$ Node $>$} \\*Event that marks the goal state }{\pageref{structslb_1_1ext_1_1event_1_1MarkedGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1MarkedStart}{slb\+::ext\+::event\+::\+Marked\+Start$<$ Node $>$} \\*Event that marks the start state }{\pageref{structslb_1_1ext_1_1event_1_1MarkedStart}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1MDHeuristic}{slb\+::ext\+::domain\+::sliding\+\_\+tile\+::\+M\+D\+Heuristic} \\*Functor for computing the Manhattan distance heuristic to the goal state with ordered tiles and blank at position 0 }{\pageref{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1MDHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1Measure}{slb\+::core\+::util\+::\+Measure} \\*The type for a single named performance measure }{\pageref{structslb_1_1core_1_1util_1_1Measure}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1MeasureSet}{slb\+::core\+::sb\+::\+Measure\+Set} \\*All the measures for a single problem instance }{\pageref{structslb_1_1core_1_1sb_1_1MeasureSet}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuBase}{slb\+::core\+::ui\+::\+Menu\+Base$<$ All\+Menus, Node $>$} \\*The base class for all the menus }{\pageref{structslb_1_1core_1_1ui_1_1MenuBase}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuEditFilter}{slb\+::core\+::ui\+::\+Menu\+Edit\+Filter$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Filter-\/$>$Edit from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuEditFilter}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuEnterState}{slb\+::core\+::ui\+::\+Menu\+Enter\+State$<$ All\+Menus, Node $>$} \\*The menu reached when choosing the Search option from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuEnterState}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuFilter}{slb\+::core\+::ui\+::\+Menu\+Filter$<$ All\+Menus, Node $>$} \\*The menu reached when choosing the \hyperlink{structslb_1_1core_1_1ui_1_1Filter}{Filter} option from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuFilter}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuGo}{slb\+::core\+::ui\+::\+Menu\+Go$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Run-\/$>$Go from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuGo}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuJump}{slb\+::core\+::ui\+::\+Menu\+Jump$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Run-\/$>$Jump }{\pageref{structslb_1_1core_1_1ui_1_1MenuJump}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuJumpStep}{slb\+::core\+::ui\+::\+Menu\+Jump\+Step$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Run-\/$>$Jump-\/$>$Step }{\pageref{structslb_1_1core_1_1ui_1_1MenuJumpStep}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuLayout}{slb\+::core\+::ui\+::\+Menu\+Layout$<$ All\+Menus, Node $>$} \\*/// The menu reached when choosing Layout from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuLayout}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuMain}{slb\+::core\+::ui\+::\+Menu\+Main$<$ All\+Menus, Node $>$} \\*The root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuMain}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuRun}{slb\+::core\+::ui\+::\+Menu\+Run$<$ All\+Menus, Node $>$} \\*The menu reached when choosing the Run option from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuRun}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuSearchDirection}{slb\+::core\+::ui\+::\+Menu\+Search\+Direction$<$ All\+Menus, Node $>$} \\*The menu for choosing the search direction after specifying the search in the search menu (reached when choosing the Search option from the root menu) }{\pageref{structslb_1_1core_1_1ui_1_1MenuSearchDirection}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuSpeed}{slb\+::core\+::ui\+::\+Menu\+Speed$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Run-\/$>$Speed from the root menu }{\pageref{structslb_1_1core_1_1ui_1_1MenuSpeed}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1MenuStep}{slb\+::core\+::ui\+::\+Menu\+Step$<$ All\+Menus, Node $>$} \\*The menu reached when choosing Run-\/$>$Step }{\pageref{structslb_1_1core_1_1ui_1_1MenuStep}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1heuristic_1_1MinMultipleGoalsT}{slb\+::ext\+::policy\+::heuristic\+::\+Min\+Multiple\+Goals\+T$<$ My\+Algorithm, Single\+Goal\+Heuristic\+T, Compare\+T $>$} \\*Computes minimum among heuristics to goals that have not been found (with the required quality) yet }{\pageref{structslb_1_1ext_1_1policy_1_1heuristic_1_1MinMultipleGoalsT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1goalHandler_1_1MultipleGoal}{slb\+::ext\+::policy\+::goal\+Handler\+::\+Multiple\+Goal$<$ My\+Algorithm $>$} \\*Handling conditions related to goal states for the case when there are multiple goal states }{\pageref{structslb_1_1ext_1_1policy_1_1goalHandler_1_1MultipleGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1NoChange}{slb\+::ext\+::event\+::\+No\+Change$<$ Node $>$} \\*An event with no visual change. However, such an event is useful by virtue of implementing the {\ttfamily event\+Str} and {\ttfamily event\+Type} methods }{\pageref{structslb_1_1ext_1_1event_1_1NoChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1node_1_1NoDataT}{slb\+::ext\+::node\+::\+No\+Data\+T$<$ State $>$} \\*Node storing nothing }{\pageref{structslb_1_1ext_1_1node_1_1NoDataT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1goalHandler_1_1NoGoal}{slb\+::ext\+::policy\+::goal\+Handler\+::\+No\+Goal$<$ My\+Algorithm $>$} \\*Handling conditions related to goal states for the case when the set of the goal states is empty }{\pageref{structslb_1_1ext_1_1policy_1_1goalHandler_1_1NoGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1NoIndex}{slb\+::ext\+::heuristic\+::differential\+::\+No\+Index} }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1NoIndex}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1Nothing}{slb\+::\+Nothing} \\*Empty structure. Too bad this is not defined by the standard }{\pageref{structslb_1_1Nothing}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1instanceMeasure_1_1Nothing}{slb\+::ext\+::instance\+Measure\+::\+Nothing} \\*No measures }{\pageref{structslb_1_1ext_1_1instanceMeasure_1_1Nothing}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1pruning_1_1Nothing}{slb\+::ext\+::policy\+::pruning\+::\+Nothing$<$ My\+Algorithm $>$} \\*No pruning }{\pageref{structslb_1_1ext_1_1policy_1_1pruning_1_1Nothing}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1commandLine_1_1Nothing}{slb\+::core\+::command\+Line\+::\+Nothing} \\*Empty additions to the command line }{\pageref{structslb_1_1core_1_1commandLine_1_1Nothing}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1NothingToDo}{slb\+::ext\+::event\+::\+Nothing\+To\+Do$<$ Node $>$} \\*Event that visualizes the fact that a node was generated, but nothing needed to be done for it }{\pageref{structslb_1_1ext_1_1event_1_1NothingToDo}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1NotParent}{slb\+::ext\+::event\+::\+Not\+Parent$<$ Node $>$} \\*Event that visualizes change of parent node }{\pageref{structslb_1_1ext_1_1event_1_1NotParent}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1grid_1_1OctileHeuristic}{slb\+::ext\+::domain\+::grid\+::\+Octile\+Heuristic$<$ State $>$} \\*The octile heuristic functor }{\pageref{structslb_1_1ext_1_1domain_1_1grid_1_1OctileHeuristic}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1OpenClosedList}{slb\+::core\+::sb\+::\+Open\+Closed\+List$<$ Open\+List $>$} \\*The type for storing open and closed lists of {\ttfamily A$\ast$} family of algorithms }{\pageref{structslb_1_1core_1_1sb_1_1OpenClosedList}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1pancake_1_1Pancake}{slb\+::ext\+::domain\+::pancake\+::\+Pancake} \\*The pancake puzzle domain }{\pageref{structslb_1_1ext_1_1domain_1_1pancake_1_1Pancake}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1PathChange}{slb\+::ext\+::event\+::\+Path\+Change$<$ Node $>$} \\*An event that applies visual changes to states and edges of the state graph along a path }{\pageref{structslb_1_1ext_1_1event_1_1PathChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1PatternLock}{slb\+::core\+::ui\+::\+Pattern\+Lock} \\*Implements a R\+A\+II technique to save and restore the current drawing. This can be used, for example, to shift the whole drawing (all one needs to do is to translate the drawing after acquiring a \hyperlink{structslb_1_1core_1_1ui_1_1PatternLock}{Pattern\+Lock}) }{\pageref{structslb_1_1core_1_1ui_1_1PatternLock}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1PerGoal}{slb\+::ext\+::algorithm\+::\+Per\+Goal$<$ log\+Flag, Node\+\_\+, Base\+Algorithm $>$} \\*{\ttfamily \hyperlink{structslb_1_1ext_1_1algorithm_1_1PerGoal}{Per\+Goal}} is a meta search algorithm for solving instances with multiple goals. It runs some other search algorithm for each goal state and combines results. Each goal state is solved independently of all others }{\pageref{structslb_1_1ext_1_1algorithm_1_1PerGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1Pivot}{slb\+::ext\+::heuristic\+::differential\+::\+Pivot$<$ State, Index $>$} \\*\hyperlink{structslb_1_1ext_1_1heuristic_1_1differential_1_1Pivot}{Pivot} with distances to all the states }{\pageref{structslb_1_1ext_1_1heuristic_1_1differential_1_1Pivot}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1gu_1_1Point}{slb\+::core\+::util\+::gu\+::\+Point} \\*The point }{\pageref{structslb_1_1core_1_1util_1_1gu_1_1Point}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1node_1_1ResponsibleGoalT}{slb\+::ext\+::node\+::\+Responsible\+Goal\+T$<$ State $>$} \\*Node for multi-\/goal search. Stores the goal responsible for heuristic value in addition to storing {\ttfamily g} and {\ttfamily f} }{\pageref{structslb_1_1ext_1_1node_1_1ResponsibleGoalT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1ResumedExpansion}{slb\+::ext\+::event\+::\+Resumed\+Expansion$<$ Node $>$} \\*Event that visualizes a node\textquotesingle{}s expansion being resumed following suspension (see \hyperlink{structslb_1_1ext_1_1event_1_1SuspendedExpansion}{Suspended\+Expansion}) }{\pageref{structslb_1_1ext_1_1event_1_1ResumedExpansion}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1Row}{slb\+::core\+::util\+::\+Row} \\*The row of the \hyperlink{structslb_1_1core_1_1util_1_1Table}{Table} }{\pageref{structslb_1_1core_1_1util_1_1Row}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1SearchNode}{slb\+::core\+::sb\+::\+Search\+Node$<$ State\+\_\+, Node\+Data\+\_\+, Bucket\+Position $>$} \\*The search node type. Inherits the data structure to make data (e.\+g. g-\/ and f-\/value) easy to access }{\pageref{structslb_1_1core_1_1sb_1_1SearchNode}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1Selected}{slb\+::ext\+::event\+::\+Selected$<$ Node $>$} \\*Event that visualizes having selected a node }{\pageref{structslb_1_1ext_1_1event_1_1Selected}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1SimpleUniformCost}{slb\+::ext\+::algorithm\+::\+Simple\+Uniform\+Cost} }{\pageref{structslb_1_1ext_1_1algorithm_1_1SimpleUniformCost}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1goalHandler_1_1SingleGoal}{slb\+::ext\+::policy\+::goal\+Handler\+::\+Single\+Goal$<$ My\+Algorithm $>$} \\*Handling conditions related to goal states for the case when there is a single goal state. Assumes that, at goal, f=g holds }{\pageref{structslb_1_1ext_1_1policy_1_1goalHandler_1_1SingleGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1heuristic_1_1SingleGoalT}{slb\+::ext\+::policy\+::heuristic\+::\+Single\+Goal\+T$<$ My\+Algorithm, Base\+Heuristic $>$} \\*Heuristic to single goal }{\pageref{structslb_1_1ext_1_1policy_1_1heuristic_1_1SingleGoalT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1slb__tcb__nothing}{slb\+::ext\+::algorithm\+::slb\+\_\+tcb\+\_\+nothing$<$ class, bool $>$} }{\pageref{structslb_1_1ext_1_1algorithm_1_1slb__tcb__nothing}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1SlidingTile}{slb\+::ext\+::domain\+::sliding\+\_\+tile\+::\+Sliding\+Tile$<$ n\+Rows, n\+Columns $>$} \\*The sliding-\/tile puzzle domain }{\pageref{structslb_1_1ext_1_1domain_1_1sliding__tile_1_1SlidingTile}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1SolutionPathChange}{slb\+::ext\+::event\+::\+Solution\+Path\+Change$<$ Node $>$} \\*An event that applies visual changes to states and edges of the state graph along the path leading to the state associated with the event }{\pageref{structslb_1_1ext_1_1event_1_1SolutionPathChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1SolvedGoal}{slb\+::ext\+::event\+::\+Solved\+Goal$<$ Node $>$} \\*Event that visualizes having found a path with required qualities to a goal }{\pageref{structslb_1_1ext_1_1event_1_1SolvedGoal}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1StateGraph}{slb\+::core\+::ui\+::\+State\+Graph$<$ State $>$} \\*The state space graph used for visualization }{\pageref{structslb_1_1core_1_1ui_1_1StateGraph}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1StateHash}{slb\+::core\+::util\+::\+State\+Hash$<$ State $>$} \\*A functor for computing the hash-\/value of a search state }{\pageref{structslb_1_1core_1_1util_1_1StateHash}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1explicit__space_1_1Grid_1_1StateIterator}{slb\+::ext\+::explicit\+\_\+space\+::\+Grid$<$ Cost\+Type\+\_\+ $>$\+::\+State\+Iterator$<$ Explicit\+State $>$} \\*The state iterator type }{\pageref{structslb_1_1ext_1_1explicit__space_1_1Grid_1_1StateIterator}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1StateNeighbor}{slb\+::core\+::sb\+::\+State\+Neighbor$<$ State\+\_\+, uniform\+Flag $>$} \\*The type for a state neighbor of a given state }{\pageref{structslb_1_1core_1_1sb_1_1StateNeighbor}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1StateSharedPtrHash}{slb\+::core\+::util\+::\+State\+Shared\+Ptr\+Hash$<$ State $>$} \\*A functor for computing the hash-\/value of a search state based on a smart pointer }{\pageref{structslb_1_1core_1_1util_1_1StateSharedPtrHash}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1generator_1_1StatesT}{slb\+::ext\+::policy\+::generator\+::\+States\+T$<$ My\+Algorithm, Heuristic $>$} \\*Generator that generates state neighbors }{\pageref{structslb_1_1ext_1_1policy_1_1generator_1_1StatesT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1sb_1_1Stats}{slb\+::core\+::sb\+::\+Stats} \\*Performance statistics of a search algorithm for a set of problem instances }{\pageref{structslb_1_1core_1_1sb_1_1Stats}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1SuspendedExpansion}{slb\+::ext\+::event\+::\+Suspended\+Expansion$<$ Node $>$} \\*Event that visualizes a node\textquotesingle{}s expansion being suspended. The expansion may be refused or resumed pending a check specific to the particular search algorithm }{\pageref{structslb_1_1ext_1_1event_1_1SuspendedExpansion}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1Table}{slb\+::core\+::util\+::\+Table} \\*The class for handling tabular output, where the columns need to be aligned. The user does not need to determine the width of columns in advance }{\pageref{structslb_1_1core_1_1util_1_1Table}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1Timer}{slb\+::core\+::util\+::\+Timer} \\*A special measure for timing }{\pageref{structslb_1_1core_1_1util_1_1Timer}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1util_1_1TimerLock}{slb\+::core\+::util\+::\+Timer\+Lock} \\*Provides R\+A\+II mechanism so the authors of search algorithm implementations should not need to worry about remembering to stop the timer for every possible execution path }{\pageref{structslb_1_1core_1_1util_1_1TimerLock}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1pruning_1_1ToParent}{slb\+::ext\+::policy\+::pruning\+::\+To\+Parent$<$ My\+Algorithm $>$} \\*Pruning the action that leads to a parent node }{\pageref{structslb_1_1ext_1_1policy_1_1pruning_1_1ToParent}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1goalHandler_1_1TotalUpdateT}{slb\+::ext\+::policy\+::goal\+Handler\+::\+Total\+Update\+T$<$ My\+Algorithm, partial\+Update\+Flag $>$} \\*Handling conditions related to goal states for the case when there are multiple goal states and the whole open list must be re-\/computed whenever a goal is solved with the required quality }{\pageref{structslb_1_1ext_1_1policy_1_1goalHandler_1_1TotalUpdateT}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1domain_1_1TrivialIndex}{slb\+::ext\+::domain\+::\+Trivial\+Index$<$ Explicit\+State $>$} \\*The index with inverse for domains whose states are integers (or a type convertible to int), so that the state itself can be used as the index. Note that these integers do not have to be consecutive, i.\+e. a map can have blocks }{\pageref{structslb_1_1ext_1_1domain_1_1TrivialIndex}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1UniformChange}{slb\+::ext\+::event\+::\+Uniform\+Change$<$ Node $>$} \\*An event that applies the same visual changes to all participating states and edges }{\pageref{structslb_1_1ext_1_1event_1_1UniformChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1algorithm_1_1UniformCost}{slb\+::ext\+::algorithm\+::\+Uniform\+Cost$<$ log\+Flag, Goal\+Handler $>$} }{\pageref{structslb_1_1ext_1_1algorithm_1_1UniformCost}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EventBase_1_1VertexChange}{slb\+::core\+::ui\+::\+Event\+Base$<$ Node $>$\+::\+Vertex\+Change} \\*Description of change of visual representation a state. Note that this is different from a visual event (see \hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent_1_1VertexChange}{Visual\+Event\+::\+Vertex\+Change}), which associates changes with vertices of the domain graph }{\pageref{structslb_1_1core_1_1ui_1_1EventBase_1_1VertexChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1VertexChange}{slb\+::ext\+::event\+::\+Vertex\+Change$<$ Node $>$} \\*An event that applies visual changes to the vertex of the state graph corresponding to the state associated with the event }{\pageref{structslb_1_1ext_1_1event_1_1VertexChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent_1_1VertexChange}{slb\+::core\+::ui\+::\+Visual\+Event$<$ State $>$\+::\+Vertex\+Change} \\*Description of change of visual representation of a single vertex }{\pageref{structslb_1_1core_1_1ui_1_1VisualEvent_1_1VertexChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1VertexColor}{slb\+::ext\+::event\+::\+Vertex\+Color$<$ Node $>$} \\*An event that changes the color of the vertex corresponding to the state associated with the event }{\pageref{structslb_1_1ext_1_1event_1_1VertexColor}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1VertexEdgeChange}{slb\+::ext\+::event\+::\+Vertex\+Edge\+Change$<$ Node $>$} \\*An event that applies visual changes to both the vertex of the state graph corresponding to the state associated with the event and the edge by which the search algorithm arrived to this state }{\pageref{structslb_1_1ext_1_1event_1_1VertexEdgeChange}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1VertexEdgeColor}{slb\+::ext\+::event\+::\+Vertex\+Edge\+Color$<$ Node $>$} \\*An event that applies a color change to both the vertex of the state graph corresponding to the state associated with the event and the edge by which the search algorithm arrived to this state }{\pageref{structslb_1_1ext_1_1event_1_1VertexEdgeColor}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1event_1_1VertexEmphasis}{slb\+::ext\+::event\+::\+Vertex\+Emphasis$<$ Node $>$} \\*An event that marks the vertex corresponding to the state associated with the event }{\pageref{structslb_1_1ext_1_1event_1_1VertexEmphasis}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VertexStyle}{slb\+::core\+::ui\+::\+Vertex\+Style} \\*Visualization properties for a single vertex }{\pageref{structslb_1_1core_1_1ui_1_1VertexStyle}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1EventBase_1_1VisualChanges}{slb\+::core\+::ui\+::\+Event\+Base$<$ Node $>$\+::\+Visual\+Changes} \\*Changes of visual representations associated with states and edges }{\pageref{structslb_1_1core_1_1ui_1_1EventBase_1_1VisualChanges}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VisualEvent}{slb\+::core\+::ui\+::\+Visual\+Event$<$ State $>$} \\*The event for visualization }{\pageref{structslb_1_1core_1_1ui_1_1VisualEvent}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1Visualizer}{slb\+::core\+::ui\+::\+Visualizer$<$ Node $>$} \\*Handles the user interface }{\pageref{structslb_1_1core_1_1ui_1_1Visualizer}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VisualizerData}{slb\+::core\+::ui\+::\+Visualizer\+Data$<$ Node $>$} \\*The base of \hyperlink{structslb_1_1core_1_1ui_1_1Visualizer}{Visualizer} holding the visualizer\textquotesingle{}s constituent components }{\pageref{structslb_1_1core_1_1ui_1_1VisualizerData}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1core_1_1ui_1_1VisualLog}{slb\+::core\+::ui\+::\+Visual\+Log$<$ Node $>$} \\*The log of events suited for visualization purposes. This log is based on the \hyperlink{structslb_1_1core_1_1ui_1_1AlgorithmLog}{Algorithm\+Log} generated by the search algorithm }{\pageref{structslb_1_1core_1_1ui_1_1VisualLog}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1voider}{slb\+::voider$<$... $>$} \\*The trait used for some S\+F\+I\+N\+AE magic }{\pageref{structslb_1_1voider}}{}
\item\contentsline{section}{\hyperlink{structslb_1_1ext_1_1policy_1_1heuristic_1_1Zero}{slb\+::ext\+::policy\+::heuristic\+::\+Zero$<$ My\+Algorithm $>$} \\*Heuristic that always returns zero }{\pageref{structslb_1_1ext_1_1policy_1_1heuristic_1_1Zero}}{}
\end{DoxyCompactList}

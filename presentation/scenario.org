This is scenario for the video demos:
* Introduction
- /intro.mp3/ Hi! My name is Meir Goldenberg. This video is a short demo of using the Heuristic Search Research Framework. We will use three different search domains to show the various features of the framework. The first domain will be path finding in grids. Before we actually run the framework for this domain, let me show you the configuration file for this example.
* Path finding in grids:
- *Show the config*
  + /flex.mp3/ The flexibility of the framework comes from using the ideas of policy-based design together with compile-time configuration that can be specified both in a separate file and on the command line.
  + /symb.mp3/ A configuration file defines pre-processor symbols. With rare exceptions, each symbol determines a behavior of the framework and will be used as a default template argument somewhere in the framework.
  + /symb_add.mp3/ Conveniently, many behaviors are shared between experiments. For example, varying search domains does not usually affect the ordering of nodes in the open list of A*. We can conveniently store common configuration in a separate header file and include that file into configurations for particular experiments. Here, I put the common configuration for the three search domains used in this demo into the file common.h. I will not go into the details of that file, but instead illustrate configuring an experiment using the symbols specific for the current experiment.   
  + /symb_example.mp3/ For example, look at the SLB_STATE symbol. This symbol is defined to be GridMapState<>, which is the class that implements the grid map domain. Like all domains, this domain is not part of the framework’s core. It is a user-contributed extension (well, in this case, I was user).  The angular brackets are needed because GridMapState is a template. However, we do not need to specify template arguments for it. Rather, we define the pre-processor symbols that determine the GridMapState’s default template arguments. For example, one of these symbols is SLB_COST_TYPE, which determines the type for storing the action costs. We specify /double/, since we want to work with 8-connected grids. 
  + /symb_flex.mp3/ Note that the set of pre-processor symbols is open-ended. That is, one may associate symbols with his own types and not worry about defining symbols used by the types that are not used in the particular current experiment. This is enabled by a special tool that takes over from the pre-processor and eliminates the unused symbols from the source before the actual compilation begins.
  + /symb_lookup.mp3/ To know what a particular symbol in the given configuration stands for, one needs to find in the on-line documentation the corresponding type and the template class for which the symbol serves as the default argument.   
- *Show the command line to run and explain its parts.*
  + /command_intro.mp3/ Now let’s close this file and move towards using the framework. Here is the command line to compile and run the framework. The name of the file containing the compile-time configuration that we saw above is specified following the CONFIG option. The OPT option specifies the command line arguments that constitute the run-time configuration of the framework. Here we specify the files containing the map and the problem instances. I have already created the problem instances, which is easily done by using a similar command line with one additional command line argument to specify the number of instances to create.
  + /command_more.mp3/ In truth, this command does much more than meets the eye. If the current version of the source code with the given configuration had ever been compiled, the executable from that previous compilation will be quickly retrieved and run. If not, the framework will be compiled and the executable will be saved for future use. This retrieval feature is extremely useful for speeding up automatic experimentation performed by scripts.
  + /average.mp3/ Let’s run the command. We see the results, which are averaged over all problem instances. It is important to note that nothing of what you see is hard-coded. Rather, each class implementing a search algorithm defines its own statistics using the facilities provided by the framework. The framework organizes these  statistics in columns for the output.
  + /per_instance.mp3/ We can modify the command line slightly to see per-instance statistics. This is done by using the perInstance switch. In this simple example, the problem instances are not ordered according to any particular criteria. However, the framework provides means, by which each instance can have attributes associated with it and instances can be sorted according to the values of those attributes in a way that is fully configurable.
  + /insights.mp3/ One of the strongest features of the framework is that it can be used to gain insights about heuristic search approaches by visualizing the search process. So, let us again modify the command line to visualize the search for solving a particular problem instance. This is done by adding the -v option and specifying the instance to be visualized. I just picked the very first instance for example.
- *Explain parts of the screen*.
  + /windows.mp3/ The user interface consists of two windows – one textual and one graphical.
  + /graphical.mp3/ The graphical window shows the search domain, which is a grid map in our case. The way the domain is layout is not hard-coded. Rather, the author of the class implementing the domain can either implement a mapping from states to (x,y)-coordinates or rely on the framework to compute a layout automatically. In this case, the former option was chosen. We will see an example of the latter option later in this demo.
  + /textual.mp3/ The textual window has three parts – the log of the events produced by the search algorithm is on the top, the middle part of the window is used to display messages to the user and the bottom part is the menu that contains the commands for performing analysis. Each event shows all the information about the corresponding search node. I am scrolling horizontally by pressing the arrow keys while holding the Ctrl key. In this case, each node stores the standard g and f-values. However, even if other values are stored with the search nodes of a particular algorithm, a special reflection mechanism is employed to eliminate the need to define special output operators for such node types. 
- *Show the visualizer’s functionality*
  + /vis_intro.mp3/ Let us walk through the available functionality. We will begin with jumping to the end of the search. In this case, the search algorithm is A*. The states in brown are in the closed list. The states in yellow are in the open list. We see that the last event occurred when the goal was found. Let us navigate and zoom to show the solution path. Navigating is done by dragging with the mouse. Zooming in or out is done by pressing + or - key, respectively, while holding the Ctrl key. It is important to note that both the events and the color coding to visualize them are fully programmable. That is, the author of an algorithm implementation defines the events specific to the algorithm and specifies how each event is going to be visualized. The framework provides base classes to make these tasks easy.
  + /jumps.mp3/ Just as we jumped to the end of the search, we can jump to any other time step. So, let us jump to step 1000. And, of course, we can also jump back to the beginning of the search.
  + /play.mp3/ To get an overall feeling for how the algorithm proceeds, we can play back the algorithm’s execution with a given speed. So, let us just set the speed to the maximum and begin the play-back.
  + /filter.mp3/ At maximal speed, this still takes too long. Well, there is too much detail. Let’s look only at node selection events and the event of the goal being discovered. This is enabled by filtering. We can choose which kinds of events should be filtered out. The filtered out events will be applied, but will not take up a time step in the simulation. Currently all events are in the filter. Let’s remove all events (I am pressing the Enter button on None) and add only the events for node selection and goal discovery (I am doing this by pressing the space button on these events). Pressing Enter on any event will finalize the filter setting. We see that the filtered out events are hidden by default. We can change the settings to show them, in which case we can still distinguish these events from the events in the filter.
  + /play_filter.mp3/ Let us play the algorithm back again, but this time with the filter enabled and the speed reduced… Much better!..
  + /*step.mp3*/ Either with or without a filter, we can step through the log forward and backwards. So, let us jump to the beginning and make a few steps forward. I am zooming in… Another few steps… A step backwards. We see that, when a filter is in place, the filtered out events are skipped and only the events in the filter are considered. In this case, only the node selection events are of interest. 
  + /search.mp3/ Lastly for this example, we can search for events concerning a certain state. So, suppose we want to see the events concerning this state on the far right. Hovering the mouse on this state shows a message with its description. So, this is the state with coordinates (150, 118). So, let’s specify this state in the search. Now we can step through the log and only the events for the chosen state that are also in the filter are visited. +By the way, if we hover over a state, for which events already took place, we are shown the type of the most recent event as well. This is useful in case we do not recall the event type to which a color corresponds+.
* Pancake
- /auto.mp3/ For domains such as a grid map, it is easy to provide a good layout, that is a mapping from states to (x,y)-coordinates. For other domains, this is hard. This is usually the case for exponential domains such as puzzles. When such a domain is not too large (currently up to a few hundred states), the framework can come up with a graph layout that exhibits symmetries. Such a layout may provide the researcher with intuition about the domain.
- /pancake.mp3/ So, I wrote a configuration file for running A* on the Pancake puzzle with the gap heuristic. One interesting feature of this configuration file is that a class responsible for additional command-line options is specified. Here, the number of pancakes is an additional command-line argument. By the way, we can see the available command line options by running the program with the –help switch. Here we go. The nPancakes option has been made available.
- /layout.mp3/ So, let’s run this configuration and specify only 4 pancakes, which results in a domain with 4!, which is 24 states. We see that the framework produced a layout. If we do not like this layout, we can request another one. Once we are satisfied with the layout, we can analyze the search just as we did for the grid map domain. So, let’s play the search.
* Education
- /teaching.mp3/ And last, but not least, the framework can be used for teaching heuristic search to students. In teaching, it is important to walk the students through artificial examples that demonstrate important concepts clearly. Here I implemented the example on page 75 of the „Heuristic Search“ book by Stefan Edelkamp.
- /dijkstra.mp3/ This example has to do with Dijkstra search on a particular constructed graph. So, in contrast to the previous examples, the heuristic is the zero-heuristic and a node with the smallest g-value is chosen from the open list at every selection. No tie-breaking mechanism is employed. Note how we un-define the corresponding symbols inherited from the common configuration. 
- /*graph.mp3*/ The graph in this example results from applying a re-weighting procedure based on a so called inconsistent heuristic. After this procedure, some edges have negative costs and the Dijkstra search on this graph can require a number of node selections that is exponential in the number of vertices of the graph.
- /labels.mp3/ So, let’s turn on the display of edge costs and vertex labels. Note that these are not hard-coded either. Rather, the labels can be easily specified by providing certain member functions for the class implementing the domain. By using the features for exploring the search that we saw in the previous examples, we might be able to convey our understanding to the students better than we would do with PowerPoint slides.
* Thank you
- /thanks.mp3/ I thank you for watching this demo and hope that you will give the framework a try.
